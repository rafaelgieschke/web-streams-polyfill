{"version":3,"file":"ponyfill.js","sources":["../src/stub/no-min/better-assert.js","../spec/reference-implementation/lib/helpers.js","../spec/reference-implementation/lib/utils.js","../spec/reference-implementation/lib/queue-with-sizes.js","../src/utils.js","../src/stub/no-min/debug.js","../spec/reference-implementation/lib/writable-stream.js","../spec/reference-implementation/lib/readable-stream.js","../spec/reference-implementation/lib/byte-length-queuing-strategy.js","../spec/reference-implementation/lib/count-queuing-strategy.js","../spec/reference-implementation/lib/transform-stream.js"],"sourcesContent":["export class AssertionError extends Error {\n}\n\nexport default function assert(test) {\n  if (!test) {\n    throw new AssertionError();\n  }\n}\n","'use strict';\nconst assert = require('better-assert');\n\nconst isFakeDetached = Symbol('is \"detached\" for our purposes');\n\nfunction IsPropertyKey(argument) {\n  return typeof argument === 'string' || typeof argument === 'symbol';\n}\n\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\n\nexports.createDataProperty = (o, p, v) => {\n  assert(exports.typeIsObject(o));\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\n};\n\nexports.createArrayFromList = elements => {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice();\n};\n\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n};\n\nexports.CreateIterResultObject = (value, done) => {\n  assert(typeof done === 'boolean');\n  const obj = {};\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\n  return obj;\n};\n\nexports.IsFiniteNonNegativeNumber = v => {\n  if (exports.IsNonNegativeNumber(v) === false) {\n    return false;\n  }\n\n  if (v === Infinity) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.IsNonNegativeNumber = v => {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (Number.isNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nfunction Call(F, V, args) {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexports.Call = Call;\n\nexports.CreateAlgorithmFromUnderlyingMethod = (underlyingObject, methodName, algoArgCount, extraArgs) => {\n  assert(underlyingObject !== undefined);\n  assert(IsPropertyKey(methodName));\n  assert(algoArgCount === 0 || algoArgCount === 1);\n  assert(Array.isArray(extraArgs));\n  const method = underlyingObject[methodName];\n  if (method !== undefined) {\n    if (typeof method !== 'function') {\n      throw new TypeError(`${method} is not a method`);\n    }\n    switch (algoArgCount) {\n      case 0: {\n        return () => {\n          return PromiseCall(method, underlyingObject, extraArgs);\n        };\n      }\n\n      case 1: {\n        return arg => {\n          const fullArgs = [arg].concat(extraArgs);\n          return PromiseCall(method, underlyingObject, fullArgs);\n        };\n      }\n    }\n  }\n  return () => Promise.resolve();\n};\n\nexports.InvokeOrNoop = (O, P, args) => {\n  assert(O !== undefined);\n  assert(IsPropertyKey(P));\n  assert(Array.isArray(args));\n\n  const method = O[P];\n  if (method === undefined) {\n    return undefined;\n  }\n\n  return Call(method, O, args);\n};\n\nfunction PromiseCall(F, V, args) {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return Promise.resolve(Call(F, V, args));\n  } catch (value) {\n    return Promise.reject(value);\n  }\n}\n\nexports.PromiseCall = PromiseCall;\n\n// Not implemented correctly\nexports.TransferArrayBuffer = O => {\n  assert(!exports.IsDetachedBuffer(O));\n  const transferredIshVersion = O.slice();\n\n  // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\n  // ArrayBuffer and checking if its byteLength starts returning 0.\n  Object.defineProperty(O, 'byteLength', {\n    get() {\n      return 0;\n    }\n  });\n  O[isFakeDetached] = true;\n\n  return transferredIshVersion;\n};\n\n// Not implemented correctly\nexports.IsDetachedBuffer = O => {\n  return isFakeDetached in O;\n};\n\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\n  highWaterMark = Number(highWaterMark);\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n  }\n\n  return highWaterMark;\n};\n\nexports.MakeSizeAlgorithmFromSizeFunction = size => {\n  if (size === undefined) {\n    return () => 1;\n  }\n  if (typeof size !== 'function') {\n    throw new TypeError('size property of a queuing strategy must be a function');\n  }\n  return chunk => size(chunk);\n};\n","'use strict';\nconst assert = require('better-assert');\n\nexports.rethrowAssertionErrorRejection = e => {\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n  // expect any errors, but assertion errors are always problematic.\n  if (e && e.constructor === assert.AssertionError) {\n    setTimeout(() => {\n      throw e;\n    }, 0);\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\n\nexports.DequeueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift();\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n};\n\nexports.EnqueueValueWithSize = (container, value, size) => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n};\n\nexports.PeekQueueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue[0];\n  return pair.value;\n};\n\nexports.ResetQueue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = [];\n  container._queueTotalSize = 0;\n};\n","export function noop() {\n  // do nothing\n}\n\nfunction getGlobals() {\n  /* global self, window, global */\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","import { noop } from '../../utils';\n\nfunction createDebugMessage(namespace, message) {\n  return `[${namespace}] ${message}`;\n}\n\nexport default function debug(namespace) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined') {\n    if (typeof console.debug === 'function') {\n      return message => console.debug(createDebugMessage(namespace, message));\n    }\n    if (typeof console.log === 'function') {\n      return message => console.log(createDebugMessage(namespace, message));\n    }\n  }\n  return noop;\n}\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:writable-stream:verbose');\n\nconst { CreateAlgorithmFromUnderlyingMethod, InvokeOrNoop, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, PeekQueueValue, ResetQueue } = require('./queue-with-sizes.js');\n\nconst AbortSteps = Symbol('[[AbortSteps]]');\nconst ErrorSteps = Symbol('[[ErrorSteps]]');\n\nclass WritableStream {\n  constructor(underlyingSink = {}, { size, highWaterMark = 1 } = {}) {\n    InitializeWritableStream(this);\n\n    const type = underlyingSink.type;\n\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  get locked() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  abort(reason) {\n    if (IsWritableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  getWriter() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nmodule.exports = {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream(stream) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = [];\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsWritableStreamLocked(stream) {\n  assert(IsWritableStream(stream) === true);\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream, reason) {\n  const state = stream._state;\n  if (state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n  const error = new TypeError('Requested to abort');\n  if (stream._pendingAbortRequest !== undefined) {\n    return Promise.reject(error);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n\n  if (wasAlreadyErroring === false) {\n    WritableStreamStartErroring(stream, error);\n  }\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream) {\n  assert(IsWritableStreamLocked(stream) === true);\n  assert(stream._state === 'writable');\n\n  const promise = new Promise((resolve, reject) => {\n    const writeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream, error) {\n  verbose('WritableStreamDealWithRejection(stream, %o)', error);\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream, reason) {\n  verbose('WritableStreamStartErroring(stream, %o)', reason);\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream) {\n  verbose('WritableStreamFinishErroring()');\n  assert(stream._state === 'erroring');\n  assert(WritableStreamHasOperationMarkedInFlight(stream) === false);\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  for (const writeRequest of stream._writeRequests) {\n    writeRequest._reject(storedError);\n  }\n  stream._writeRequests = [];\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring === true) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  promise.then(\n      () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      },\n      reason => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    verbose('WritableStreamHasOperationMarkedInFlight() is false');\n    return false;\n  }\n\n  verbose('WritableStreamHasOperationMarkedInFlight() is true');\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  verbose('WritableStreamRejectCloseAndClosedPromiseIfNeeded()');\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n    writer._closedPromise.catch(() => {});\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n  assert(stream._state === 'writable');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure === true) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(backpressure === false);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\nclass WritableStreamDefaultWriter {\n  constructor(stream) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n    }\n    if (IsWritableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n      this._closedPromise.catch(() => {});\n    }\n  }\n\n  get closed() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  get desiredSize() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  get ready() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  abort(reason) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  close() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return Promise.reject(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  releaseLock() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  write(chunk) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.reject(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const promise = new Promise((resolve, reject) => {\n    const closeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  if (stream._backpressure === true && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.resolve();\n  }\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n  writer._closedPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  verbose('WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)', error);\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n  writer._readyPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n}\n\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return Promise.reject(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nclass WritableStreamDefaultController {\n  constructor() {\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n  }\n\n  error(e) {\n    if (IsWritableStreamDefaultController(this) === false) {\n      throw new TypeError(\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  [AbortSteps](reason) {\n    return this._abortAlgorithm(reason);\n  }\n\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                              abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(IsWritableStream(stream) === true);\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = Promise.resolve(startResult);\n  startPromise.then(\n      () => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      },\n      r => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n      }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n  assert(underlyingSink !== undefined);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\n  }\n\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n\nfunction WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize(controller, 'close', 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  const writeRecord = { chunk };\n\n  try {\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  verbose('WritableStreamDefaultControllerAdvanceQueueIfNeeded()');\n  const stream = controller._controlledWritableStream;\n\n  if (controller._started === false) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return;\n  }\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const writeRecord = PeekQueueValue(controller);\n  if (writeRecord === 'close') {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  sinkClosePromise.then(\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  sinkWritePromise.then(\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    reason => {\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller, error) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name) {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = new Promise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  writer._closedPromise = Promise.resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResolve(writer) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer) {\n  verbose('defaultWriterReadyPromiseInitialize()');\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseInitializeAsRejected(writer, %o)', reason);\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  verbose('defaultWriterReadyPromiseInitializeAsResolved()');\n  writer._readyPromise = Promise.resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n  verbose('defaultWriterReadyPromiseReject(writer, %o)', reason);\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer) {\n  verbose('defaultWriterReadyPromiseReset()');\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseResetToRejected(writer, %o)', reason);\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseResolve(writer) {\n  verbose('defaultWriterReadyPromiseResolve()');\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n","'use strict';\nconst assert = require('better-assert');\nconst { ArrayBufferCopy, CreateAlgorithmFromUnderlyingMethod, CreateIterResultObject, IsFiniteNonNegativeNumber,\n        InvokeOrNoop, IsDetachedBuffer, TransferArrayBuffer, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, createArrayFromList, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, ResetQueue } = require('./queue-with-sizes.js');\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight } =\n      require('./writable-stream.js');\n\nconst CancelSteps = Symbol('[[CancelSteps]]');\nconst PullSteps = Symbol('[[PullSteps]]');\n\nclass ReadableStream {\n  constructor(underlyingSource = {}, { size, highWaterMark } = {}) {\n    InitializeReadableStream(this);\n    const type = underlyingSource.type;\n    const typeString = String(type);\n    if (typeString === 'bytes') {\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      if (size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n    } else if (type === undefined) {\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n    } else {\n      throw new RangeError('Invalid type is specified');\n    }\n  }\n\n  get locked() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  getReader({ mode } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    mode = String(mode);\n\n    if (mode === 'byob') {\n      return AcquireReadableStreamBYOBReader(this);\n    }\n\n    throw new RangeError('Invalid mode is specified');\n  }\n\n  pipeThrough({ writable, readable }, options) {\n    if (writable === undefined || readable === undefined) {\n      throw new TypeError('readable and writable arguments must be defined');\n    }\n\n    const promise = this.pipeTo(writable, options);\n\n    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);\n\n    return readable;\n  }\n\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('pipeTo'));\n    }\n    if (IsWritableStream(dest) === false) {\n      return Promise.reject(\n        new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n    }\n    if (IsWritableStreamLocked(dest) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n    }\n\n    const reader = AcquireReadableStreamDefaultReader(this);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n\n    let shuttingDown = false;\n\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      // Using reader and writer, read all chunks from this and write them to dest\n      // - Backpressure must be enforced\n      // - Shutdown must stop all activity\n      function pipeLoop() {\n        if (shuttingDown === true) {\n          return Promise.resolve();\n        }\n\n        return writer._readyPromise.then(() => {\n          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\n            if (done === true) {\n              return;\n            }\n\n            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(() => {});\n          });\n        })\n        .then(pipeLoop);\n      }\n\n      // Errors must be propagated forward\n      isOrBecomesErrored(this, reader._closedPromise, storedError => {\n        if (preventAbort === false) {\n          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Errors must be propagated backward\n      isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Closing must be propagated forward\n      isOrBecomesClosed(this, reader._closedPromise, () => {\n        if (preventClose === false) {\n          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n        } else {\n          shutdown();\n        }\n      });\n\n      // Closing must be propagated backward\n      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\n        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);\n        } else {\n          shutdown(true, destClosed);\n        }\n      }\n\n      pipeLoop().catch(err => {\n        currentWrite = Promise.resolve();\n        rethrowAssertionErrorRejection(err);\n      });\n\n      function waitForWritesToFinish() {\n        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n        // for that too.\n        const oldCurrentWrite = currentWrite;\n        return currentWrite.then(() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n      }\n\n      function isOrBecomesErrored(stream, promise, action) {\n        if (stream._state === 'errored') {\n          action(stream._storedError);\n        } else {\n          promise.catch(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function isOrBecomesClosed(stream, promise, action) {\n        if (stream._state === 'closed') {\n          action();\n        } else {\n          promise.then(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdownWithAction(action, originalIsError, originalError) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(doTheRest);\n        } else {\n          doTheRest();\n        }\n\n        function doTheRest() {\n          action().then(\n            () => finalize(originalIsError, originalError),\n            newError => finalize(true, newError)\n          )\n          .catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdown(isError, error) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(() => finalize(isError, error)).catch(rethrowAssertionErrorRejection);\n        } else {\n          finalize(isError, error);\n        }\n      }\n\n      function finalize(isError, error) {\n        WritableStreamDefaultWriterRelease(writer);\n        ReadableStreamReaderGenericRelease(reader);\n\n        if (isError) {\n          reject(error);\n        } else {\n          resolve(undefined);\n        }\n      }\n    });\n  }\n\n  tee() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return createArrayFromList(branches);\n  }\n}\n\nmodule.exports = {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  ReadableStream,\n  IsReadableStreamDisturbed,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure,\n  ReadableStreamDefaultControllerCanCloseOrEnqueue\n};\n\n// Abstract operations for the ReadableStream.\n\nfunction AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n}\n\nfunction AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  SetUpReadableStreamDefaultController(\n      stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 0,\n                                  autoAllocateChunkSize = undefined) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nfunction IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDisturbed(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  return stream._disturbed;\n}\n\nfunction IsReadableStreamLocked(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n  assert(IsReadableStream(stream) === true);\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader(stream);\n\n  let closedOrErrored = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n\n  let resolveCancelPromise;\n  const cancelPromise = new Promise(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm() {\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\n      assert(typeIsObject(result));\n      const value = result.value;\n      const done = result.done;\n      assert(typeof done === 'boolean');\n\n      if (done === true && closedOrErrored === false) {\n        if (canceled1 === false) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n        if (canceled2 === false) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n        closedOrErrored = true;\n      }\n\n      if (closedOrErrored === true) {\n        return;\n      }\n\n      const value1 = value;\n      const value2 = value;\n\n      // There is no way to access the cloning code right now in the reference implementation.\n      // If we add one then we'll need an implementation for serializable objects.\n      // if (canceled2 === false && cloneForBranch2 === true) {\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n      // }\n\n      if (canceled1 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n      }\n\n      if (canceled2 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n      }\n    });\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {}\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  reader._closedPromise.catch(r => {\n    if (closedOrErrored === true) {\n      return;\n    }\n\n    ReadableStreamDefaultControllerErrorIfNeeded(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerErrorIfNeeded(branch2._readableStreamController, r);\n    closedOrErrored = true;\n  });\n\n  return [branch1, branch2];\n}\n\n// ReadableStream API exposed for controllers.\n\nfunction ReadableStreamAddReadIntoRequest(stream) {\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  const promise = new Promise((resolve, reject) => {\n    const readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamAddReadRequest(stream) {\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\n  assert(stream._state === 'readable');\n\n  const promise = new Promise((resolve, reject) => {\n    const readRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._reader._readRequests.push(readRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return sourceCancelPromise.then(() => undefined);\n}\n\nfunction ReadableStreamClose(stream) {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const { _resolve } of reader._readRequests) {\n      _resolve(CreateIterResultObject(undefined, true));\n    }\n    reader._readRequests = [];\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  return undefined;\n}\n\nfunction ReadableStreamError(stream, e) {\n  assert(IsReadableStream(stream) === true);\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const readRequest of reader._readRequests) {\n      readRequest._reject(e);\n    }\n\n    reader._readRequests = [];\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n\n    for (const readIntoRequest of reader._readIntoRequests) {\n      readIntoRequest._reject(e);\n    }\n\n    reader._readIntoRequests = [];\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n  reader._closedPromise.catch(() => {});\n}\n\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift();\n  readIntoRequest._resolve(CreateIterResultObject(chunk, done));\n}\n\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift();\n  readRequest._resolve(CreateIterResultObject(chunk, done));\n}\n\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\n\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\n\nfunction ReadableStreamHasBYOBReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamBYOBReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamHasDefaultReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nclass ReadableStreamDefaultReader {\n  constructor(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n    }\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = [];\n  }\n\n  get closed() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    return ReadableStreamDefaultReaderRead(this);\n  }\n\n  releaseLock() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nclass ReadableStreamBYOBReader {\n  constructor(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\n          'byte source');\n    }\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n          'source');\n    }\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = [];\n  }\n\n  get closed() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return Promise.reject(new TypeError('view must be an array buffer view'));\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\n    }\n\n    if (view.byteLength === 0) {\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\n    }\n\n    return ReadableStreamBYOBReaderRead(this, view);\n  }\n\n  releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\n// Abstract operations for the readers.\n\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    reader._closedPromise.catch(() => {});\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nfunction ReadableStreamReaderGenericRelease(reader) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n  reader._closedPromise.catch(() => {});\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n\nfunction ReadableStreamBYOBReaderRead(reader, view) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  // Controllers must implement this.\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\n}\n\nfunction ReadableStreamDefaultReaderRead(reader) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(CreateIterResultObject(undefined, true));\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(stream._state === 'readable');\n\n  return stream._readableStreamController[PullSteps]();\n}\n\n// Controllers\n\nclass ReadableStreamDefaultController {\n  constructor() {\n    throw new TypeError();\n  }\n\n  get desiredSize() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    const stream = this._controlledReadableStream;\n    if (stream._state !== 'readable') {\n      throw new TypeError(`The stream is ${stream._state} and so cannot be errored`);\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    ResetQueue(this);\n    return this._cancelAlgorithm(reason);\n  }\n\n  [PullSteps]() {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      return Promise.resolve(CreateIterResultObject(chunk, false));\n    }\n\n    const pendingPromise = ReadableStreamAddReadRequest(stream);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  }\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n      return undefined;\n    },\n    e => {\n      ReadableStreamDefaultControllerErrorIfNeeded(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction ReadableStreamDefaultControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamClose(stream);\n  }\n}\n\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n\n  assert(stream._state === 'readable');\n\n  ResetQueue(controller);\n\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableStreamDefaultControllerErrorIfNeeded(controller, e) {\n  if (controller._controlledReadableStream._state === 'readable') {\n    ReadableStreamDefaultControllerError(controller, e);\n  }\n}\n\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const state = controller._controlledReadableStream._state;\n\n  if (controller._closeRequested === false && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction SetUpReadableStreamDefaultController(\n  stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n    () => {\n      controller._started = true;\n\n      assert(controller._pulling === false);\n      assert(controller._pullAgain === false);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableStreamDefaultControllerErrorIfNeeded(controller, r);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark,\n                                                                  sizeAlgorithm) {\n  assert(underlyingSource !== undefined);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\n\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                       highWaterMark, sizeAlgorithm);\n}\n\nclass ReadableStreamBYOBRequest {\n  constructor() {\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n  }\n\n  get view() {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view.buffer) === true) {\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nclass ReadableByteStreamController {\n  constructor() {\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n  }\n\n  get byobRequest() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      const view = new Uint8Array(firstDescriptor.buffer,\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n      this._byobRequest = byobRequest;\n    }\n\n    return this._byobRequest;\n  }\n\n  get desiredSize() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n    }\n\n    if (IsDetachedBuffer(chunk.buffer) === true) {\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    const stream = this._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n      throw new TypeError(`The stream is ${stream._state} and so cannot be errored`);\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    if (this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      firstDescriptor.bytesFilled = 0;\n    }\n\n    ResetQueue(this);\n\n    return this._cancelAlgorithm(reason);\n  }\n\n  [PullSteps]() {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream) === true);\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      const entry = this._queue.shift();\n      this._queueTotalSize -= entry.byteLength;\n\n      ReadableByteStreamControllerHandleQueueDrain(this);\n\n      let view;\n      try {\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n      } catch (viewE) {\n        return Promise.reject(viewE);\n      }\n\n      return Promise.resolve(CreateIterResultObject(view, false));\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        return Promise.reject(bufferE);\n      }\n\n      const pullIntoDescriptor = {\n        buffer,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        ctor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    const promise = ReadableStreamAddReadRequest(stream);\n\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n\n    return promise;\n  }\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      if (controller._controlledReadableByteStream._state === 'readable') {\n        ReadableByteStreamControllerError(controller, e);\n      }\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = [];\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  assert(stream._state !== 'errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.ctor(\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue[0];\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (ready === false) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  assert(controller._closeRequested === false);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerPullInto(controller, view) {\n  const stream = controller._controlledReadableByteStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor;\n\n  const buffer = TransferArrayBuffer(view.buffer);\n  const pullIntoDescriptor = {\n    buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    return ReadableStreamAddReadIntoRequest(stream);\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    return Promise.resolve(CreateIterResultObject(emptyView, true));\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      return Promise.resolve(CreateIterResultObject(filledView, false));\n    }\n\n    if (controller._closeRequested === true) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      return Promise.reject(e);\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  const promise = ReadableStreamAddReadIntoRequest(stream);\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n\n  return promise;\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  assert(firstDescriptor.bytesFilled === 0);\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream) === true) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n    throw new RangeError('bytesWritten out of range');\n  }\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(stream._state === 'readable');\n\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  const descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nfunction ReadableByteStreamControllerClose(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableStreamClose(stream);\n}\n\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(IsReadableStreamLocked(stream) === false);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n}\n\nfunction ReadableByteStreamControllerError(controller, e) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(stream._state === 'readable');\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableByteStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n    throw new RangeError('bytesWritten must be a finite');\n  }\n\n  assert(controller._pendingPullIntos.length > 0);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n\n  firstDescriptor.buffer = view.buffer;\n\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                           highWaterMark, autoAllocateChunkSize) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = [];\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n\n        assert(controller._pulling === false);\n        assert(controller._pullAgain === false);\n\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      },\n      r => {\n        if (stream._state === 'readable') {\n          ReadableByteStreamControllerError(controller, r);\n        }\n      }\n  )\n      .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n  assert(underlyingByteSource !== undefined);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\n\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize !== undefined) {\n    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\n    }\n  }\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n}\n\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n  assert(IsReadableByteStreamController(controller) === true);\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view) === true);\n  assert(IsDetachedBuffer(view.buffer) === false);\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\n// Helper functions for the readers.\n\nfunction readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\nfunction defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = new Promise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  reader._closedPromise = Promise.resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  reader._closedPromise = Promise.reject(reason);\n}\n\nfunction defaultReaderClosedPromiseResolve(reader) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction byobReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Helper function for ReadableStream pipeThrough\n\nfunction ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {\n  try {\n    // This relies on the brand-check that is enforced by Promise.prototype.then(). As with the rest of the reference\n    // implementation, it doesn't attempt to do the right thing if someone has modified the global environment.\n    Promise.prototype.then.call(promise, undefined, () => {});\n  } catch (e) {\n    // The brand check failed, therefore the internal slot is not present and there's nothing further to do.\n  }\n}\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class ByteLengthQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size(chunk) {\n    return chunk.byteLength;\n  }\n};\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class CountQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size() {\n    return 1;\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:transform-stream:verbose');\nconst { InvokeOrNoop, CreateAlgorithmFromUnderlyingMethod, PromiseCall, typeIsObject,\n        ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction } = require('./helpers.js');\nconst { CreateReadableStream, ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue,\n        ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize,\n        ReadableStreamDefaultControllerHasBackpressure,\n        ReadableStreamDefaultControllerCanCloseOrEnqueue } = require('./readable-stream.js');\nconst { CreateWritableStream, WritableStreamDefaultControllerErrorIfNeeded } = require('./writable-stream.js');\n\n// Class TransformStream\n\nclass TransformStream {\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\n    const readableType = transformer.readableType;\n\n    if (readableType !== undefined) {\n      throw new RangeError('Invalid readable type specified');\n    }\n\n    const writableType = transformer.writableType;\n\n    if (writableType !== undefined) {\n      throw new RangeError('Invalid writable type specified');\n    }\n\n    const writableSizeFunction = writableStrategy.size;\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\n    let writableHighWaterMark = writableStrategy.highWaterMark;\n    if (writableHighWaterMark === undefined) {\n      writableHighWaterMark = 1;\n    }\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\n\n    const readableSizeFunction = readableStrategy.size;\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\n    let readableHighWaterMark = readableStrategy.highWaterMark;\n    if (readableHighWaterMark === undefined) {\n      readableHighWaterMark = 0;\n    }\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\n\n    let startPromise_resolve;\n    const startPromise = new Promise(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                              readableSizeAlgorithm);\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\n    startPromise_resolve(startResult);\n  }\n\n  get readable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  get writable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\n// Transform Stream Abstract Operations\n\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark = 1,\n                               writableSizeAlgorithm = () => 1, readableHighWaterMark = 0,\n                               readableSizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve;\n  const startPromise = new Promise(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm,\n                                   readableHighWaterMark, readableSizeAlgorithm) {\n  function startAlgorithm() {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk) {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm() {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream);\n  }\n\n  function closeAlgorithm() {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm() {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason) {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return Promise.resolve();\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true);\n\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n  stream._transformStreamController = undefined;\n}\n\nfunction IsTransformStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n  verbose('TransformStreamError()');\n\n  if (stream._readable._state === 'readable') {\n    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  }\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure === true) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n  verbose(`TransformStreamSetBackpressure() [backpressure = ${backpressure}]`);\n\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = new Promise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\nclass TransformStreamDefaultController {\n  constructor() {\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n  }\n\n  get desiredSize() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  enqueue(chunk) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(reason) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  terminate() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  assert(IsTransformStream(stream) === true);\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  assert(transformer !== undefined);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm = chunk => {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\n      return Promise.resolve();\n    } catch (transformResultE) {\n      return Promise.reject(transformResultE);\n    }\n  };\n  const transformMethod = transformer.transform;\n  if (transformMethod !== undefined) {\n    if (typeof transformMethod !== 'function') {\n      throw new TypeError('transform is not a method');\n    }\n    transformAlgorithm = chunk => {\n      const transformPromise = PromiseCall(transformMethod, transformer, [chunk, controller]);\n      return transformPromise.catch(e => {\n        TransformStreamError(stream, e);\n        throw e;\n      });\n    };\n  }\n\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  verbose('TransformStreamDefaultControllerEnqueue()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure === true);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerTerminate(controller) {\n  verbose('TransformStreamDefaultControllerTerminate()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n    ReadableStreamDefaultControllerClose(readableController);\n  }\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  verbose('TransformStreamDefaultSinkWriteAlgorithm()');\n\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure === true) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return backpressureChangePromise\n        .then(() => {\n          const writable = stream._writable;\n          const state = writable._state;\n          if (state === 'erroring') {\n            throw writable._storedError;\n          }\n          assert(state === 'writable');\n          return controller._transformAlgorithm(chunk);\n        });\n  }\n\n  return controller._transformAlgorithm(chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream) {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  const e = new TypeError('Writable side aborted');\n  TransformStreamError(stream, e);\n  return Promise.resolve();\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  verbose('TransformStreamDefaultSinkCloseAlgorithm()');\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  const flushPromise = stream._transformStreamController._flushAlgorithm();\n  // Return a promise that is fulfilled with undefined on success.\n  return flushPromise.then(() => {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n    const readableController = readable._readableStreamController;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n      ReadableStreamDefaultControllerClose(readableController);\n    }\n  }).catch(r => {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n  verbose('TransformStreamDefaultSourcePullAlgorithm()');\n\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure === true);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\nmodule.exports = { CreateTransformStream, TransformStream };\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n"],"names":["AssertionError","Error","assert","test","isFakeDetached","Symbol","IsPropertyKey","argument","x","o","p","v","exports","typeIsObject","defineProperty","value","writable","enumerable","configurable","elements","slice","dest","destOffset","src","srcOffset","n","Uint8Array","set","done","obj","IsNonNegativeNumber","Infinity","Number","isNaN","Call","F","V","args","TypeError","Function","prototype","apply","call","underlyingObject","methodName","algoArgCount","extraArgs","undefined","Array","isArray","method","PromiseCall","fullArgs","arg","concat","Promise","resolve","O","P","reject","IsDetachedBuffer","transferredIshVersion","highWaterMark","RangeError","size","chunk","e","constructor","IsFiniteNonNegativeNumber","require$$0","container","_queue","length","pair","shift","_queueTotalSize","push","noop","createDebugMessage","namespace","message","debug","console","log","verbose","CreateAlgorithmFromUnderlyingMethod","require$$1","InvokeOrNoop","ValidateAndNormalizeHighWaterMark","MakeSizeAlgorithmFromSizeFunction","rethrowAssertionErrorRejection","require$$2","DequeueValue","require$$3","EnqueueValueWithSize","PeekQueueValue","ResetQueue","AbortSteps","ErrorSteps","WritableStream","underlyingSink","type","sizeAlgorithm","abort","reason","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","getWriter","AcquireWritableStreamDefaultWriter","stream","WritableStreamDefaultWriter","CreateWritableStream","startAlgorithm","writeAlgorithm","closeAlgorithm","abortAlgorithm","Object","create","controller","WritableStreamDefaultController","InitializeWritableStream","_state","_storedError","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","hasOwnProperty","state","error","wasAlreadyErroring","promise","WritableStreamAddWriteRequest","writeRequest","WritableStreamDealWithRejection","WritableStreamStartErroring","writer","WritableStreamHasOperationMarkedInFlight","_started","WritableStreamFinishErroring","storedError","_reject","abortRequest","_wasAlreadyErroring","_reason","then","_resolve","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamFinishInFlightClose","WritableStreamFinishInFlightCloseWithError","WritableStreamCloseQueuedOrInFlight","WritableStreamMarkCloseRequestInFlight","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamRejectCloseAndClosedPromiseIfNeeded","_closedPromise","catch","WritableStreamUpdateBackpressure","backpressure","_ownerWritableStream","_readyPromise","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultWriterAbort","close","WritableStreamDefaultWriterClose","releaseLock","write","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriterGetDesiredSize","closeRequest","WritableStreamDefaultWriterCloseWithErrorPropagation","WritableStreamDefaultWriterEnsureClosedPromiseRejected","_closedPromiseState","WritableStreamDefaultWriterEnsureReadyPromiseRejected","_readyPromiseState","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterRelease","releasedError","chunkSize","WritableStreamDefaultControllerGetChunkSize","IsWritableStreamDefaultController","_controlledWritableStream","_abortAlgorithm","SetUpWritableStreamDefaultController","_strategySizeAlgorithm","_strategyHWM","_writeAlgorithm","_closeAlgorithm","WritableStreamDefaultControllerGetBackpressure","startResult","startPromise","r","SetUpWritableStreamDefaultControllerFromUnderlyingSink","WritableStreamDefaultControllerClose","chunkSizeE","WritableStreamDefaultControllerWrite","writeRecord","enqueueE","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultControllerProcessClose","sinkClosePromise","WritableStreamDefaultControllerProcessWrite","sinkWritePromise","desiredSize","WritableStreamDefaultControllerError","name","defaultWriterClosedPromiseInitialize","_closedPromise_resolve","_closedPromise_reject","defaultWriterClosedPromiseInitializeAsRejected","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseReject","defaultWriterClosedPromiseResetToRejected","defaultWriterClosedPromiseResolve","defaultWriterReadyPromiseInitialize","_readyPromise_resolve","_readyPromise_reject","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseReset","defaultWriterReadyPromiseResetToRejected","defaultWriterReadyPromiseResolve","ArrayBufferCopy","CreateIterResultObject","TransferArrayBuffer","createArrayFromList","CancelSteps","PullSteps","ReadableStream","underlyingSource","typeString","String","cancel","IsReadableStream","IsReadableStreamLocked","ReadableStreamCancel","getReader","mode","AcquireReadableStreamDefaultReader","AcquireReadableStreamBYOBReader","pipeThrough","options","readable","pipeTo","preventClose","preventAbort","preventCancel","Boolean","reader","shuttingDown","currentWrite","pipeLoop","ReadableStreamDefaultReaderRead","destClosed","err","waitForWritesToFinish","oldCurrentWrite","isOrBecomesErrored","action","isOrBecomesClosed","shutdownWithAction","originalIsError","originalError","doTheRest","finalize","newError","shutdown","isError","tee","branches","ReadableStreamTee","ReadableStreamBYOBReader","ReadableStreamDefaultReader","CreateReadableStream","pullAlgorithm","cancelAlgorithm","ReadableStreamDefaultController","CreateReadableByteStream","autoAllocateChunkSize","isInteger","ReadableByteStreamController","InitializeReadableStream","_reader","_disturbed","IsReadableStreamDisturbed","cloneForBranch2","closedOrErrored","canceled1","canceled2","reason1","reason2","branch1","branch2","resolveCancelPromise","cancelPromise","result","_readableStreamController","value1","value2","cancel1Algorithm","compositeReason","cancelResult","cancel2Algorithm","ReadableStreamAddReadIntoRequest","IsReadableStreamBYOBReader","readIntoRequest","_readIntoRequests","ReadableStreamAddReadRequest","IsReadableStreamDefaultReader","readRequest","_readRequests","sourceCancelPromise","ReadableStreamClose","ReadableStreamError","ReadableStreamFulfillReadIntoRequest","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","ReadableStreamHasDefaultReader","defaultReaderBrandCheckException","_ownerReadableStream","readerLockException","ReadableStreamReaderGenericCancel","read","IsReadableByteStreamController","byobReaderBrandCheckException","view","ArrayBuffer","isView","buffer","byteLength","ReadableStreamBYOBReaderRead","ReadableStreamReaderGenericInitialize","ReadableStreamReaderGenericRelease","ReadableByteStreamControllerPullInto","IsReadableStreamDefaultController","defaultControllerBrandCheckException","ReadableStreamDefaultControllerCanCloseOrEnqueue","enqueue","ReadableStreamDefaultControllerEnqueue","_controlledReadableStream","_cancelAlgorithm","_closeRequested","pendingPromise","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCallPullIfNeeded","shouldPull","ReadableStreamDefaultControllerShouldCallPull","_pulling","_pullAgain","pullPromise","_pullAlgorithm","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerErrorIfNeeded","ReadableStreamDefaultControllerHasBackpressure","SetUpReadableStreamDefaultController","SetUpReadableStreamDefaultControllerFromUnderlyingSource","ReadableStreamBYOBRequest","respond","bytesWritten","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_associatedReadableByteStreamController","_view","respondWithNewView","byteStreamControllerBrandCheckException","_controlledReadableByteStream","_pendingPullIntos","firstDescriptor","bytesFilled","entry","byteOffset","viewE","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","_byobRequest","byobRequest","ReadableByteStreamControllerGetDesiredSize","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","readerType","elementSize","ctor","ReadableByteStreamControllerEnqueueChunkToQueue","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","Math","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerHandleQueueDrain","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","DataView","BYTES_PER_ELEMENT","emptyView","ReadableByteStreamControllerRespondInClosedState","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInReadableState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInternal","descriptor","ReadableByteStreamControllerClose","firstPendingPullInto","ReadableByteStreamControllerEnqueue","transferredBuffer","transferredView","ReadableByteStreamControllerError","ReadableByteStreamControllerRespond","ReadableByteStreamControllerRespondWithNewView","SetUpReadableByteStreamController","SetUpReadableByteStreamControllerFromUnderlyingSource","underlyingByteSource","SetUpReadableStreamBYOBRequest","request","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsRejected","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseReject","defaultReaderClosedPromiseResetToRejected","defaultReaderClosedPromiseResolve","ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue","createDataProperty","TransformStream","transformer","writableStrategy","readableStrategy","readableType","writableType","writableSizeFunction","writableSizeAlgorithm","writableHighWaterMark","readableSizeFunction","readableSizeAlgorithm","readableHighWaterMark","startPromise_resolve","_transformStreamController","IsTransformStream","_readable","_writable","CreateTransformStream","transformAlgorithm","flushAlgorithm","TransformStreamDefaultController","InitializeTransformStream","TransformStreamDefaultSinkWriteAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSourcePullAlgorithm","_backpressureChangePromise","_backpressureChangePromise_resolve","TransformStreamError","TransformStreamErrorWritableAndUnblockWrite","TransformStreamSetBackpressure","IsTransformStreamDefaultController","terminate","readableController","_controlledTransformStream","SetUpTransformStreamDefaultController","_transformAlgorithm","_flushAlgorithm","SetUpTransformStreamDefaultControllerFromTransformer","transformResultE","transformMethod","transform","transformPromise","TransformStreamDefaultControllerEnqueue","TransformStreamDefaultControllerError","TransformStreamDefaultControllerTerminate","backpressureChangePromise","flushPromise"],"mappings":"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"}