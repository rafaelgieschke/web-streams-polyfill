!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r(e.WebStreamsPolyfill={})}(this,function(e){"use strict";class AssertionError extends Error{}function r(e){if(!e)throw new AssertionError}var t={AssertionError:AssertionError,default:r};var o=t&&r||t,n=function(e,r){return e(r={exports:{}},r.exports),r.exports}(function(e,r){const t=Symbol('is "detached" for our purposes');function n(e){return"string"==typeof e||"symbol"==typeof e}function a(e,r,t){if("function"!=typeof e)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,r,t)}function i(e,r,t){o("function"==typeof e),o(void 0!==r),o(Array.isArray(t));try{return Promise.resolve(a(e,r,t))}catch(e){return Promise.reject(e)}}r.typeIsObject=(e=>"object"==typeof e&&null!==e||"function"==typeof e),r.createDataProperty=((e,t,n)=>{o(r.typeIsObject(e)),Object.defineProperty(e,t,{value:n,writable:!0,enumerable:!0,configurable:!0})}),r.createArrayFromList=(e=>e.slice()),r.ArrayBufferCopy=((e,r,t,o,n)=>{new Uint8Array(e).set(new Uint8Array(t,o,n),r)}),r.CreateIterResultObject=((e,r)=>{o("boolean"==typeof r);const t={};return Object.defineProperty(t,"value",{value:e,enumerable:!0,writable:!0,configurable:!0}),Object.defineProperty(t,"done",{value:r,enumerable:!0,writable:!0,configurable:!0}),t}),r.IsFiniteNonNegativeNumber=(e=>!1!==r.IsNonNegativeNumber(e)&&e!==1/0),r.IsNonNegativeNumber=(e=>"number"==typeof e&&(!Number.isNaN(e)&&!(e<0))),r.Call=a,r.CreateAlgorithmFromUnderlyingMethod=((e,r,t,a)=>{o(void 0!==e),o(n(r)),o(0===t||1===t),o(Array.isArray(a));const s=e[r];if(void 0!==s){if("function"!=typeof s)throw new TypeError(`${s} is not a method`);switch(t){case 0:return()=>i(s,e,a);case 1:return r=>{const t=[r].concat(a);return i(s,e,t)}}}return()=>Promise.resolve()}),r.InvokeOrNoop=((e,r,t)=>{o(void 0!==e),o(n(r)),o(Array.isArray(t));const i=e[r];if(void 0!==i)return a(i,e,t)}),r.PromiseCall=i,r.TransferArrayBuffer=(e=>{o(!r.IsDetachedBuffer(e));const n=e.slice();return Object.defineProperty(e,"byteLength",{get:()=>0}),e[t]=!0,n}),r.IsDetachedBuffer=(e=>t in e),r.ValidateAndNormalizeHighWaterMark=(e=>{if(e=Number(e),Number.isNaN(e)||e<0)throw new RangeError("highWaterMark property of a queuing strategy must be non-negative and non-NaN");return e}),r.MakeSizeAlgorithmFromSizeFunction=(e=>{if(void 0===e)return()=>1;if("function"!=typeof e)throw new TypeError("size property of a queuing strategy must be a function");return r=>e(r)})}),a=(n.typeIsObject,n.createDataProperty,n.createArrayFromList,n.ArrayBufferCopy,n.CreateIterResultObject,n.IsFiniteNonNegativeNumber,n.IsNonNegativeNumber,n.Call,n.CreateAlgorithmFromUnderlyingMethod,n.InvokeOrNoop,n.PromiseCall,n.TransferArrayBuffer,n.IsDetachedBuffer,n.ValidateAndNormalizeHighWaterMark,n.MakeSizeAlgorithmFromSizeFunction,{rethrowAssertionErrorRejection:e=>{e&&e.constructor===o.AssertionError&&setTimeout(()=>{throw e},0)}});const{IsFiniteNonNegativeNumber:i}=n;var s={DequeueValue:e=>{o("_queue"in e&&"_queueTotalSize"in e),o(e._queue.length>0);const r=e._queue.shift();return e._queueTotalSize-=r.size,e._queueTotalSize<0&&(e._queueTotalSize=0),r.value},EnqueueValueWithSize:(e,r,t)=>{if(o("_queue"in e&&"_queueTotalSize"in e),t=Number(t),!i(t))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:r,size:t}),e._queueTotalSize+=t},PeekQueueValue:e=>{return o("_queue"in e&&"_queueTotalSize"in e),o(e._queue.length>0),e._queue[0].value},ResetQueue:e=>{o("_queue"in e&&"_queueTotalSize"in e),e._queue=[],e._queueTotalSize=0}};function l(){}const c="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0;function u(e,r){return`[${e}] ${r}`}function d(e){if("undefined"!=typeof console){if("function"==typeof console.debug)return r=>console.debug(u(e,r));if("function"==typeof console.log)return r=>console.log(u(e,r))}return l}var _={default:d},f=_&&d||_;const m=f("streams:writable-stream:verbose"),{CreateAlgorithmFromUnderlyingMethod:b,InvokeOrNoop:h,ValidateAndNormalizeHighWaterMark:y,IsNonNegativeNumber:p,MakeSizeAlgorithmFromSizeFunction:w,typeIsObject:S}=n,{rethrowAssertionErrorRejection:g}=a,{DequeueValue:v,EnqueueValueWithSize:R,PeekQueueValue:P,ResetQueue:q}=s,T=Symbol("[[AbortSteps]]"),C=Symbol("[[ErrorSteps]]");class WritableStream{constructor(e={},{size:r,highWaterMark:t=1}={}){if(E(this),void 0!==e.type)throw new RangeError("Invalid type is specified");const n=w(r);!function(e,r,t,n){o(void 0!==r);const a=Object.create(WritableStreamDefaultController.prototype);const i=b(r,"write",1,[a]),s=b(r,"close",0,[]),l=b(r,"abort",1,[]);U(e,a,function(){return h(r,"start",[a])},i,s,l,t,n)}(this,e,t=y(t),n)}get locked(){if(!1===A(this))throw ee("locked");return O(this)}abort(e){return!1===A(this)?Promise.reject(ee("abort")):!0===O(this)?Promise.reject(new TypeError("Cannot abort a stream that already has a writer")):B(this,e)}getWriter(){if(!1===A(this))throw ee("getWriter");return W(this)}}var j={AcquireWritableStreamDefaultWriter:W,CreateWritableStream:function(e,r,t,n,a=1,i=(()=>1)){o(!0===p(a));const s=Object.create(WritableStream.prototype);E(s);const l=Object.create(WritableStreamDefaultController.prototype);return U(s,l,e,r,t,n,a,i),s},IsWritableStream:A,IsWritableStreamLocked:O,WritableStream:WritableStream,WritableStreamAbort:B,WritableStreamDefaultControllerErrorIfNeeded:K,WritableStreamDefaultWriterCloseWithErrorPropagation:function(e){const r=e._ownerWritableStream;o(void 0!==r);const t=r._state;if(!0===D(r)||"closed"===t)return Promise.resolve();if("errored"===t)return Promise.reject(r._storedError);return o("writable"===t||"erroring"===t),$(e)},WritableStreamDefaultWriterRelease:Q,WritableStreamDefaultWriterWrite:x,WritableStreamCloseQueuedOrInFlight:D};function W(e){return new WritableStreamDefaultWriter(e)}function E(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=[],e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function A(e){return!!S(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")}function O(e){return o(!0===A(e)),void 0!==e._writer}function B(e,r){const t=e._state;if("closed"===t)return Promise.resolve(void 0);if("errored"===t)return Promise.reject(e._storedError);const n=new TypeError("Requested to abort");if(void 0!==e._pendingAbortRequest)return Promise.reject(n);o("writable"===t||"erroring"===t);let a=!1;"erroring"===t&&(a=!0,r=void 0);const i=new Promise((t,o)=>{e._pendingAbortRequest={_resolve:t,_reject:o,_reason:r,_wasAlreadyErroring:a}});return!1===a&&I(e,n),i}function z(e,r){m("WritableStreamDealWithRejection(stream, %o)",r);const t=e._state;"writable"!==t?(o("erroring"===t),k(e)):I(e,r)}function I(e,r){m("WritableStreamStartErroring(stream, %o)",r),o(void 0===e._storedError),o("writable"===e._state);const t=e._writableStreamController;o(void 0!==t),e._state="erroring",e._storedError=r;const n=e._writer;void 0!==n&&H(n,r),!1===N(e)&&!0===t._started&&k(e)}function k(e){m("WritableStreamFinishErroring()"),o("erroring"===e._state),o(!1===N(e)),e._state="errored",e._writableStreamController[C]();const r=e._storedError;for(const t of e._writeRequests)t._reject(r);if(e._writeRequests=[],void 0===e._pendingAbortRequest)return void L(e);const t=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,!0===t._wasAlreadyErroring)return t._reject(r),void L(e);e._writableStreamController[T](t._reason).then(()=>{t._resolve(),L(e)},r=>{t._reject(r),L(e)})}function F(e){o(void 0!==e._inFlightCloseRequest),e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0;const r=e._state;o("writable"===r||"erroring"===r),"erroring"===r&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state="closed";const t=e._writer;void 0!==t&&function(e){o(void 0!==e._closedPromise_resolve),o(void 0!==e._closedPromise_reject),o("pending"===e._closedPromiseState),e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}(t),o(void 0===e._pendingAbortRequest),o(void 0===e._storedError)}function D(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function N(e){return void 0===e._inFlightWriteRequest&&void 0===e._inFlightCloseRequest?(m("WritableStreamHasOperationMarkedInFlight() is false"),!1):(m("WritableStreamHasOperationMarkedInFlight() is true"),!0)}function L(e){m("WritableStreamRejectCloseAndClosedPromiseIfNeeded()"),o("errored"===e._state),void 0!==e._closeRequest&&(o(void 0===e._inFlightCloseRequest),e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const r=e._writer;void 0!==r&&(ne(r,e._storedError),r._closedPromise.catch(()=>{}))}function M(e,r){o("writable"===e._state),o(!1===D(e));const t=e._writer;void 0!==t&&r!==e._backpressure&&(!0===r?function(e){m("defaultWriterReadyPromiseReset()"),o(void 0===e._readyPromise_resolve),o(void 0===e._readyPromise_reject),e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}(t):(o(!1===r),se(t))),e._backpressure=r}class WritableStreamDefaultWriter{constructor(e){if(!1===A(e))throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");if(!0===O(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const r=e._state;if("writable"===r)!1===D(e)&&!0===e._backpressure?function(e){m("defaultWriterReadyPromiseInitialize()"),e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}(this):ie(this),oe(this);else if("erroring"===r)ae(this,e._storedError),this._readyPromise.catch(()=>{}),oe(this);else if("closed"===r)ie(this),function(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}(this);else{o("errored"===r);const t=e._storedError;ae(this,t),this._readyPromise.catch(()=>{}),function(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}(this,t),this._closedPromise.catch(()=>{})}}get closed(){return!1===V(this)?Promise.reject(re("closed")):this._closedPromise}get desiredSize(){if(!1===V(this))throw re("desiredSize");if(void 0===this._ownerWritableStream)throw te("desiredSize");return function(e){const r=e._ownerWritableStream,t=r._state;if("errored"===t||"erroring"===t)return null;if("closed"===t)return 0;return G(r._writableStreamController)}(this)}get ready(){return!1===V(this)?Promise.reject(re("ready")):this._readyPromise}abort(e){return!1===V(this)?Promise.reject(re("abort")):void 0===this._ownerWritableStream?Promise.reject(te("abort")):function(e,r){const t=e._ownerWritableStream;return o(void 0!==t),B(t,r)}(this,e)}close(){if(!1===V(this))return Promise.reject(re("close"));const e=this._ownerWritableStream;return void 0===e?Promise.reject(te("close")):!0===D(e)?Promise.reject(new TypeError("cannot close an already-closing stream")):$(this)}releaseLock(){if(!1===V(this))throw re("releaseLock");const e=this._ownerWritableStream;void 0!==e&&(o(void 0!==e._writer),Q(this))}write(e){return!1===V(this)?Promise.reject(re("write")):void 0===this._ownerWritableStream?Promise.reject(te("write to")):x(this,e)}}function V(e){return!!S(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")}function $(e){const r=e._ownerWritableStream;o(void 0!==r);const t=r._state;if("closed"===t||"errored"===t)return Promise.reject(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));o("writable"===t||"erroring"===t),o(!1===D(r));const n=new Promise((e,t)=>{const o={_resolve:e,_reject:t};r._closeRequest=o});return!0===r._backpressure&&"writable"===t&&se(e),function(e){R(e,"close",0),J(e)}(r._writableStreamController),n}function Y(e,r){"pending"===e._closedPromiseState?ne(e,r):function(e,r){o(void 0===e._closedPromise_resolve),o(void 0===e._closedPromise_reject),o("pending"!==e._closedPromiseState),e._closedPromise=Promise.reject(r),e._closedPromiseState="rejected"}(e,r),e._closedPromise.catch(()=>{})}function H(e,r){m("WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)",r),"pending"===e._readyPromiseState?function(e,r){m("defaultWriterReadyPromiseReject(writer, %o)",r),o(void 0!==e._readyPromise_resolve),o(void 0!==e._readyPromise_reject),e._readyPromise_reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}(e,r):function(e,r){m("defaultWriterReadyPromiseResetToRejected(writer, %o)",r),o(void 0===e._readyPromise_resolve),o(void 0===e._readyPromise_reject),e._readyPromise=Promise.reject(r),e._readyPromiseState="rejected"}(e,r),e._readyPromise.catch(()=>{})}function Q(e){const r=e._ownerWritableStream;o(void 0!==r),o(r._writer===e);const t=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");H(e,t),Y(e,t),r._writer=void 0,e._ownerWritableStream=void 0}function x(e,r){const t=e._ownerWritableStream;o(void 0!==t);const n=t._writableStreamController,a=function(e,r){try{return e._strategySizeAlgorithm(r)}catch(r){return K(e,r),1}}(n,r);if(t!==e._ownerWritableStream)return Promise.reject(te("write to"));const i=t._state;if("errored"===i)return Promise.reject(t._storedError);if(!0===D(t)||"closed"===i)return Promise.reject(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===i)return Promise.reject(t._storedError);o("writable"===i);const s=function(e){return o(!0===O(e)),o("writable"===e._state),new Promise((r,t)=>{const o={_resolve:r,_reject:t};e._writeRequests.push(o)})}(t);return function(e,r,t){const o={chunk:r};try{R(e,o,t)}catch(r){return void K(e,r)}const n=e._controlledWritableStream;if(!1===D(n)&&"writable"===n._state){const r=X(e);M(n,r)}J(e)}(n,r,a),s}class WritableStreamDefaultController{constructor(){throw new TypeError("WritableStreamDefaultController cannot be constructed explicitly")}error(e){if(!1===function(e){if(!S(e))return!1;if(!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream"))return!1;return!0}(this))throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");"writable"===this._controlledWritableStream._state&&Z(this,e)}[T](e){return this._abortAlgorithm(e)}[C](){q(this)}}function U(e,r,t,n,a,i,s,l){o(!0===A(e)),o(void 0===e._writableStreamController),r._controlledWritableStream=e,e._writableStreamController=r,r._queue=void 0,r._queueTotalSize=void 0,q(r),r._started=!1,r._strategySizeAlgorithm=l,r._strategyHWM=s,r._writeAlgorithm=n,r._closeAlgorithm=a,r._abortAlgorithm=i;const c=X(r);M(e,c);const u=t();Promise.resolve(u).then(()=>{o("writable"===e._state||"erroring"===e._state),r._started=!0,J(r)},t=>{o("writable"===e._state||"erroring"===e._state),r._started=!0,z(e,t)}).catch(g)}function G(e){return e._strategyHWM-e._queueTotalSize}function J(e){m("WritableStreamDefaultControllerAdvanceQueueIfNeeded()");const r=e._controlledWritableStream;if(!1===e._started)return;if(void 0!==r._inFlightWriteRequest)return;const t=r._state;if("closed"===t||"errored"===t)return;if("erroring"===t)return void k(r);if(0===e._queue.length)return;const n=P(e);"close"===n?function(e){const r=e._controlledWritableStream;(function(e){o(void 0===e._inFlightCloseRequest),o(void 0!==e._closeRequest),e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0})(r),v(e),o(0===e._queue.length),e._closeAlgorithm().then(()=>{F(r)},e=>{!function(e,r){o(void 0!==e._inFlightCloseRequest),e._inFlightCloseRequest._reject(r),e._inFlightCloseRequest=void 0,o("writable"===e._state||"erroring"===e._state),void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(r),e._pendingAbortRequest=void 0),z(e,r)}(r,e)}).catch(g)}(e):function(e,r){const t=e._controlledWritableStream;(function(e){o(void 0===e._inFlightWriteRequest),o(0!==e._writeRequests.length),e._inFlightWriteRequest=e._writeRequests.shift()})(t),e._writeAlgorithm(r).then(()=>{!function(e){o(void 0!==e._inFlightWriteRequest),e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0}(t);const r=t._state;if(o("writable"===r||"erroring"===r),v(e),!1===D(t)&&"writable"===r){const r=X(e);M(t,r)}J(e)},e=>{!function(e,r){o(void 0!==e._inFlightWriteRequest),e._inFlightWriteRequest._reject(r),e._inFlightWriteRequest=void 0,o("writable"===e._state||"erroring"===e._state),z(e,r)}(t,e)}).catch(g)}(e,n.chunk)}function K(e,r){"writable"===e._controlledWritableStream._state&&Z(e,r)}function X(e){return G(e)<=0}function Z(e,r){const t=e._controlledWritableStream;o("writable"===t._state),I(t,r)}function ee(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function re(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function te(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function oe(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t,e._closedPromiseState="pending"})}function ne(e,r){o(void 0!==e._closedPromise_resolve),o(void 0!==e._closedPromise_reject),o("pending"===e._closedPromiseState),e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}function ae(e,r){m("defaultWriterReadyPromiseInitializeAsRejected(writer, %o)",r),e._readyPromise=Promise.reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}function ie(e){m("defaultWriterReadyPromiseInitializeAsResolved()"),e._readyPromise=Promise.resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}function se(e){m("defaultWriterReadyPromiseResolve()"),o(void 0!==e._readyPromise_resolve),o(void 0!==e._readyPromise_reject),e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}var le=j.WritableStream;const{ArrayBufferCopy:ce,CreateAlgorithmFromUnderlyingMethod:ue,CreateIterResultObject:de,IsFiniteNonNegativeNumber:_e,InvokeOrNoop:fe,IsDetachedBuffer:me,TransferArrayBuffer:be,ValidateAndNormalizeHighWaterMark:he,IsNonNegativeNumber:ye,MakeSizeAlgorithmFromSizeFunction:pe,createArrayFromList:we,typeIsObject:Se}=n,{rethrowAssertionErrorRejection:ge}=a,{DequeueValue:ve,EnqueueValueWithSize:Re,ResetQueue:Pe}=s,{AcquireWritableStreamDefaultWriter:qe,IsWritableStream:Te,IsWritableStreamLocked:Ce,WritableStreamAbort:je,WritableStreamDefaultWriterCloseWithErrorPropagation:We,WritableStreamDefaultWriterRelease:Ee,WritableStreamDefaultWriterWrite:Ae,WritableStreamCloseQueuedOrInFlight:Oe}=j,Be=Symbol("[[CancelSteps]]"),ze=Symbol("[[PullSteps]]");class ReadableStream{constructor(e={},{size:r,highWaterMark:t}={}){De(this);const n=e.type;if("bytes"===String(n)){if(void 0===t&&(t=0),t=he(t),void 0!==r)throw new RangeError("The strategy for a byte stream cannot have a size function");!function(e,r,t){o(void 0!==r);const n=Object.create(ReadableByteStreamController.prototype);const a=ue(r,"pull",0,[n]),i=ue(r,"cancel",1,[]),s=r.autoAllocateChunkSize;if(void 0!==s&&(!1===Number.isInteger(s)||s<=0))throw new RangeError("autoAllocateChunkSize must be a positive integer");Wr(e,n,function(){return fe(r,"start",[n])},a,i,t,s)}(this,e,t)}else{if(void 0!==n)throw new RangeError("Invalid type is specified");void 0===t&&(t=1),function(e,r,t,n){o(void 0!==r);const a=Object.create(ReadableStreamDefaultController.prototype);const i=ue(r,"pull",0,[a]),s=ue(r,"cancel",1,[]);_r(e,a,function(){return fe(r,"start",[a])},i,s,t,n)}(this,e,t=he(t),pe(r))}}get locked(){if(!1===Ne(this))throw Er("locked");return Le(this)}cancel(e){return!1===Ne(this)?Promise.reject(Er("cancel")):!0===Le(this)?Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")):$e(this,e)}getReader({mode:e}={}){if(!1===Ne(this))throw Er("getReader");if(void 0===e)return ke(this);if("byob"===(e=String(e)))return function(e){return new ReadableStreamBYOBReader(e)}(this);throw new RangeError("Invalid mode is specified")}pipeThrough({writable:e,readable:r},t){if(void 0===e||void 0===r)throw new TypeError("readable and writable arguments must be defined");return function(e){try{Promise.prototype.then.call(e,void 0,()=>{})}catch(e){}}(this.pipeTo(e,t)),r}pipeTo(e,{preventClose:r,preventAbort:t,preventCancel:o}={}){if(!1===Ne(this))return Promise.reject(Er("pipeTo"));if(!1===Te(e))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));if(r=Boolean(r),t=Boolean(t),o=Boolean(o),!0===Le(this))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));if(!0===Ce(e))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));const n=ke(this),a=qe(e);let i=!1,s=Promise.resolve();return new Promise((l,c)=>{if(d(this,n._closedPromise,r=>{!1===t?_(()=>je(e,r),!0,r):f(!0,r)}),d(e,a._closedPromise,e=>{!1===o?_(()=>$e(this,e),!0,e):f(!0,e)}),function(e,r,t){"closed"===e._state?t():r.then(t).catch(ge)}(this,n._closedPromise,()=>{!1===r?_(()=>We(a)):f()}),!0===Oe(e)||"closed"===e._state){const e=new TypeError("the destination writable stream closed before all data could be piped to it");!1===o?_(()=>$e(this,e),!0,e):f(!0,e)}function u(){const e=s;return s.then(()=>e!==s?u():void 0)}function d(e,r,t){"errored"===e._state?t(e._storedError):r.catch(t).catch(ge)}function _(r,t,o){function n(){r().then(()=>m(t,o),e=>m(!0,e)).catch(ge)}!0!==i&&(i=!0,"writable"===e._state&&!1===Oe(e)?u().then(n):n())}function f(r,t){!0!==i&&(i=!0,"writable"===e._state&&!1===Oe(e)?u().then(()=>m(r,t)).catch(ge):m(r,t))}function m(e,r){Ee(a),rr(n),e?c(r):l(void 0)}(function e(){return!0===i?Promise.resolve():a._readyPromise.then(()=>tr(n).then(({value:e,done:r})=>{!0!==r&&(s=Ae(a,e).catch(()=>{}))})).then(e)})().catch(e=>{s=Promise.resolve(),ge(e)})})}tee(){if(!1===Ne(this))throw Er("tee");const e=function(e,r){o(!0===Ne(e)),o("boolean"==typeof r);const t=ke(e);let n,a,i,s,l,c=!1,u=!1,d=!1;const _=new Promise(e=>{l=e});function f(){return tr(t).then(e=>{o(Se(e));const r=e.value,t=e.done;if(o("boolean"==typeof t),!0===t&&!1===c&&(!1===u&&ir(i._readableStreamController),!1===d&&ir(s._readableStreamController),c=!0),!0===c)return;const n=r,a=r;!1===u&&sr(i._readableStreamController,n),!1===d&&sr(s._readableStreamController,a)})}function m(){}return i=Fe(m,f,function(r){if(u=!0,n=r,!0===d){const r=we([n,a]),t=$e(e,r);l(t)}return _}),s=Fe(m,f,function(r){if(d=!0,a=r,!0===u){const r=we([n,a]),t=$e(e,r);l(t)}return _}),t._closedPromise.catch(e=>{!0!==c&&(cr(i._readableStreamController,e),cr(s._readableStreamController,e),c=!0)}),[i,s]}(this,!1);return we(e)}}var Ie={CreateReadableByteStream:function(e,r,t,n=0,a){o(!0===ye(n)),void 0!==a&&(o(!0===Number.isInteger(a)),o(a>0));const i=Object.create(ReadableStream.prototype);De(i);const s=Object.create(ReadableByteStreamController.prototype);return Wr(i,s,e,r,t,n,a),i},CreateReadableStream:Fe,ReadableStream:ReadableStream,IsReadableStreamDisturbed:function(e){return o(!0===Ne(e)),e._disturbed},ReadableStreamDefaultControllerClose:ir,ReadableStreamDefaultControllerEnqueue:sr,ReadableStreamDefaultControllerError:lr,ReadableStreamDefaultControllerGetDesiredSize:ur,ReadableStreamDefaultControllerHasBackpressure:function(e){if(!0===ar(e))return!1;return!0},ReadableStreamDefaultControllerCanCloseOrEnqueue:dr};function ke(e){return new ReadableStreamDefaultReader(e)}function Fe(e,r,t,n=1,a=(()=>1)){o(!0===ye(n));const i=Object.create(ReadableStream.prototype);return De(i),_r(i,Object.create(ReadableStreamDefaultController.prototype),e,r,t,n,a),i}function De(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function Ne(e){return!!Se(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")}function Le(e){return o(!0===Ne(e)),void 0!==e._reader}function Me(e){return o(!0===Ke(e._reader)),o("readable"===e._state||"closed"===e._state),new Promise((r,t)=>{const o={_resolve:r,_reject:t};e._reader._readIntoRequests.push(o)})}function Ve(e){return o(!0===Xe(e._reader)),o("readable"===e._state),new Promise((r,t)=>{const o={_resolve:r,_reject:t};e._reader._readRequests.push(o)})}function $e(e,r){if(e._disturbed=!0,"closed"===e._state)return Promise.resolve(void 0);if("errored"===e._state)return Promise.reject(e._storedError);return Ye(e),e._readableStreamController[Be](r).then(()=>void 0)}function Ye(e){o("readable"===e._state),e._state="closed";const r=e._reader;if(void 0!==r){if(!0===Xe(r)){for(const{_resolve:e}of r._readRequests)e(de(void 0,!0));r._readRequests=[]}!function(e){o(void 0!==e._closedPromise_resolve),o(void 0!==e._closedPromise_reject),e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(r)}}function He(e,r){o(!0===Ne(e)),o("readable"===e._state),e._state="errored",e._storedError=r;const t=e._reader;if(void 0!==t){if(!0===Xe(t)){for(const e of t._readRequests)e._reject(r);t._readRequests=[]}else{o(Ke(t));for(const e of t._readIntoRequests)e._reject(r);t._readIntoRequests=[]}Br(t,r),t._closedPromise.catch(()=>{})}}function Qe(e,r,t){const n=e._reader;o(n._readRequests.length>0),n._readRequests.shift()._resolve(de(r,t))}function xe(e){return e._reader._readIntoRequests.length}function Ue(e){return e._reader._readRequests.length}function Ge(e){const r=e._reader;return void 0!==r&&!1!==Ke(r)}function Je(e){const r=e._reader;return void 0!==r&&!1!==Xe(r)}class ReadableStreamDefaultReader{constructor(e){if(!1===Ne(e))throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");if(!0===Le(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");Ze(this,e),this._readRequests=[]}get closed(){return!1===Xe(this)?Promise.reject(Or("closed")):this._closedPromise}cancel(e){return!1===Xe(this)?Promise.reject(Or("cancel")):void 0===this._ownerReadableStream?Promise.reject(Ar("cancel")):er(this,e)}read(){return!1===Xe(this)?Promise.reject(Or("read")):void 0===this._ownerReadableStream?Promise.reject(Ar("read from")):tr(this)}releaseLock(){if(!1===Xe(this))throw Or("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");rr(this)}}}class ReadableStreamBYOBReader{constructor(e){if(!Ne(e))throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");if(!1===fr(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");if(Le(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");Ze(this,e),this._readIntoRequests=[]}get closed(){return Ke(this)?this._closedPromise:Promise.reject(zr("closed"))}cancel(e){return Ke(this)?void 0===this._ownerReadableStream?Promise.reject(Ar("cancel")):er(this,e):Promise.reject(zr("cancel"))}read(e){return Ke(this)?void 0===this._ownerReadableStream?Promise.reject(Ar("read from")):ArrayBuffer.isView(e)?!0===me(e.buffer)?Promise.reject(new TypeError("Cannot read into a view onto a detached ArrayBuffer")):0===e.byteLength?Promise.reject(new TypeError("view must have non-zero byteLength")):function(e,r){const t=e._ownerReadableStream;if(o(void 0!==t),t._disturbed=!0,"errored"===t._state)return Promise.reject(t._storedError);return function(e,r){const t=e._controlledReadableByteStream;let o=1;r.constructor!==DataView&&(o=r.constructor.BYTES_PER_ELEMENT);const n=r.constructor,a={buffer:be(r.buffer),byteOffset:r.byteOffset,byteLength:r.byteLength,bytesFilled:0,elementSize:o,ctor:n,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(a),Me(t);if("closed"===t._state){const e=new r.constructor(a.buffer,a.byteOffset,0);return Promise.resolve(de(e,!0))}if(e._queueTotalSize>0){if(!0===Sr(e,a)){const r=pr(a);return vr(e),Promise.resolve(de(r,!1))}if(!0===e._closeRequested){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");return Cr(e,r),Promise.reject(r)}}e._pendingPullIntos.push(a);const i=Me(t);return br(e),i}(t._readableStreamController,r)}(this,e):Promise.reject(new TypeError("view must be an array buffer view")):Promise.reject(zr("read"))}releaseLock(){if(!Ke(this))throw zr("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");rr(this)}}}function Ke(e){return!!Se(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")}function Xe(e){return!!Se(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")}function Ze(e,r){e._ownerReadableStream=r,r._reader=e,"readable"===r._state?function(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t})}(e):"closed"===r._state?function(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(e):(o("errored"===r._state),function(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}(e,r._storedError),e._closedPromise.catch(()=>{}))}function er(e,r){const t=e._ownerReadableStream;return o(void 0!==t),$e(t,r)}function rr(e){o(void 0!==e._ownerReadableStream),o(e._ownerReadableStream._reader===e),"readable"===e._ownerReadableStream._state?Br(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(e,r){o(void 0===e._closedPromise_resolve),o(void 0===e._closedPromise_reject),e._closedPromise=Promise.reject(r)}(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._closedPromise.catch(()=>{}),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0}function tr(e){const r=e._ownerReadableStream;return o(void 0!==r),r._disturbed=!0,"closed"===r._state?Promise.resolve(de(void 0,!0)):"errored"===r._state?Promise.reject(r._storedError):(o("readable"===r._state),r._readableStreamController[ze]())}class ReadableStreamDefaultController{constructor(){throw new TypeError}get desiredSize(){if(!1===or(this))throw Ir("desiredSize");return ur(this)}close(){if(!1===or(this))throw Ir("close");if(!1===dr(this))throw new TypeError("The stream is not in a state that permits close");ir(this)}enqueue(e){if(!1===or(this))throw Ir("enqueue");if(!1===dr(this))throw new TypeError("The stream is not in a state that permits enqueue");return sr(this,e)}error(e){if(!1===or(this))throw Ir("error");const r=this._controlledReadableStream;if("readable"!==r._state)throw new TypeError(`The stream is ${r._state} and so cannot be errored`);lr(this,e)}[Be](e){return Pe(this),this._cancelAlgorithm(e)}[ze](){const e=this._controlledReadableStream;if(this._queue.length>0){const r=ve(this);return!0===this._closeRequested&&0===this._queue.length?Ye(e):nr(this),Promise.resolve(de(r,!1))}const r=Ve(e);return nr(this),r}}function or(e){return!!Se(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")}function nr(e){!1!==ar(e)&&(!0!==e._pulling?(o(!1===e._pullAgain),e._pulling=!0,e._pullAlgorithm().then(()=>{if(e._pulling=!1,!0===e._pullAgain)return e._pullAgain=!1,nr(e)},r=>{cr(e,r)}).catch(ge)):e._pullAgain=!0)}function ar(e){const r=e._controlledReadableStream;return!1!==dr(e)&&(!1!==e._started&&(!0===Le(r)&&Ue(r)>0||ur(e)>0))}function ir(e){const r=e._controlledReadableStream;o(!0===dr(e)),e._closeRequested=!0,0===e._queue.length&&Ye(r)}function sr(e,r){const t=e._controlledReadableStream;if(o(!0===dr(e)),!0===Le(t)&&Ue(t)>0)Qe(t,r,!1);else{let t;try{t=e._strategySizeAlgorithm(r)}catch(r){throw cr(e,r),r}try{Re(e,r,t)}catch(r){throw cr(e,r),r}}nr(e)}function lr(e,r){const t=e._controlledReadableStream;o("readable"===t._state),Pe(e),He(t,r)}function cr(e,r){"readable"===e._controlledReadableStream._state&&lr(e,r)}function ur(e){const r=e._controlledReadableStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function dr(e){const r=e._controlledReadableStream._state;return!1===e._closeRequested&&"readable"===r}function _r(e,r,t,n,a,i,s){o(void 0===e._readableStreamController),r._controlledReadableStream=e,r._queue=void 0,r._queueTotalSize=void 0,Pe(r),r._started=!1,r._closeRequested=!1,r._pullAgain=!1,r._pulling=!1,r._strategySizeAlgorithm=s,r._strategyHWM=i,r._pullAlgorithm=n,r._cancelAlgorithm=a,e._readableStreamController=r;const l=t();Promise.resolve(l).then(()=>{r._started=!0,o(!1===r._pulling),o(!1===r._pullAgain),nr(r)},e=>{cr(r,e)}).catch(ge)}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("ReadableStreamBYOBRequest cannot be used directly")}get view(){if(!1===mr(this))throw kr("view");return this._view}respond(e){if(!1===mr(this))throw kr("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!0===me(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");!function(e,r){if(r=Number(r),!1===_e(r))throw new RangeError("bytesWritten must be a finite");o(e._pendingPullIntos.length>0),qr(e,r)}(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!1===mr(this))throw kr("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(!0===me(e.buffer))throw new TypeError("The supplied view's buffer has been detached and so cannot be used as a response");!function(e,r){o(e._pendingPullIntos.length>0);const t=e._pendingPullIntos[0];if(t.byteOffset+t.bytesFilled!==r.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(t.byteLength!==r.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");t.buffer=r.buffer,qr(e,r.byteLength)}(this._associatedReadableByteStreamController,e)}}class ReadableByteStreamController{constructor(){throw new TypeError("ReadableByteStreamController constructor cannot be used directly")}get byobRequest(){if(!1===fr(this))throw Fr("byobRequest");if(void 0===this._byobRequest&&this._pendingPullIntos.length>0){const e=this._pendingPullIntos[0],r=new Uint8Array(e.buffer,e.byteOffset+e.bytesFilled,e.byteLength-e.bytesFilled),t=Object.create(ReadableStreamBYOBRequest.prototype);!function(e,r,t){o(!0===fr(r)),o("object"==typeof t),o(!0===ArrayBuffer.isView(t)),o(!1===me(t.buffer)),e._associatedReadableByteStreamController=r,e._view=t}(t,this,r),this._byobRequest=t}return this._byobRequest}get desiredSize(){if(!1===fr(this))throw Fr("desiredSize");return jr(this)}close(){if(!1===fr(this))throw Fr("close");if(!0===this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if("readable"!==e)throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);!function(e){const r=e._controlledReadableByteStream;if(o(!1===e._closeRequested),o("readable"===r._state),e._queueTotalSize>0)return void(e._closeRequested=!0);if(e._pendingPullIntos.length>0){const r=e._pendingPullIntos[0];if(r.bytesFilled>0){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");throw Cr(e,r),r}}Ye(r)}(this)}enqueue(e){if(!1===fr(this))throw Fr("enqueue");if(!0===this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if("readable"!==r)throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);if(!ArrayBuffer.isView(e))throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");if(!0===me(e.buffer))throw new TypeError("Cannot enqueue a view onto a detached ArrayBuffer");!function(e,r){const t=e._controlledReadableByteStream;o(!1===e._closeRequested),o("readable"===t._state);const n=r.buffer,a=r.byteOffset,i=r.byteLength,s=be(n);if(!0===Je(t))if(0===Ue(t))wr(e,s,a,i);else{o(0===e._queue.length);const r=new Uint8Array(s,a,i);Qe(t,r,!1)}else!0===Ge(t)?(wr(e,s,a,i),Pr(e)):(o(!1===Le(t)),wr(e,s,a,i))}(this,e)}error(e){if(!1===fr(this))throw Fr("error");const r=this._controlledReadableByteStream;if("readable"!==r._state)throw new TypeError(`The stream is ${r._state} and so cannot be errored`);Cr(this,e)}[Be](e){if(this._pendingPullIntos.length>0){this._pendingPullIntos[0].bytesFilled=0}return Pe(this),this._cancelAlgorithm(e)}[ze](){const e=this._controlledReadableByteStream;if(o(!0===Je(e)),this._queueTotalSize>0){o(0===Ue(e));const r=this._queue.shift();let t;this._queueTotalSize-=r.byteLength,vr(this);try{t=new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}catch(e){return Promise.reject(e)}return Promise.resolve(de(t,!1))}const r=this._autoAllocateChunkSize;if(void 0!==r){let e;try{e=new ArrayBuffer(r)}catch(e){return Promise.reject(e)}const t={buffer:e,byteOffset:0,byteLength:r,bytesFilled:0,elementSize:1,ctor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(t)}const t=Ve(e);return br(this),t}}function fr(e){return!!Se(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")}function mr(e){return!!Se(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")}function br(e){!1!==function(e){const r=e._controlledReadableByteStream;if("readable"!==r._state)return!1;if(!0===e._closeRequested)return!1;if(!1===e._started)return!1;if(!0===Je(r)&&Ue(r)>0)return!0;if(!0===Ge(r)&&xe(r)>0)return!0;if(jr(e)>0)return!0;return!1}(e)&&(!0!==e._pulling?(o(!1===e._pullAgain),e._pulling=!0,e._pullAlgorithm().then(()=>{e._pulling=!1,!0===e._pullAgain&&(e._pullAgain=!1,br(e))},r=>{"readable"===e._controlledReadableByteStream._state&&Cr(e,r)}).catch(ge)):e._pullAgain=!0)}function hr(e){Rr(e),e._pendingPullIntos=[]}function yr(e,r){o("errored"!==e._state);let t=!1;"closed"===e._state&&(o(0===r.bytesFilled),t=!0);const n=pr(r);"default"===r.readerType?Qe(e,n,t):(o("byob"===r.readerType),function(e,r,t){const n=e._reader;o(n._readIntoRequests.length>0),n._readIntoRequests.shift()._resolve(de(r,t))}(e,n,t))}function pr(e){const r=e.bytesFilled,t=e.elementSize;return o(r<=e.byteLength),o(r%t==0),new e.ctor(e.buffer,e.byteOffset,r/t)}function wr(e,r,t,o){e._queue.push({buffer:r,byteOffset:t,byteLength:o}),e._queueTotalSize+=o}function Sr(e,r){const t=r.elementSize,n=r.bytesFilled-r.bytesFilled%t,a=Math.min(e._queueTotalSize,r.byteLength-r.bytesFilled),i=r.bytesFilled+a,s=i-i%t;let l=a,c=!1;s>n&&(l=s-r.bytesFilled,c=!0);const u=e._queue;for(;l>0;){const t=u[0],o=Math.min(l,t.byteLength),n=r.byteOffset+r.bytesFilled;ce(r.buffer,n,t.buffer,t.byteOffset,o),t.byteLength===o?u.shift():(t.byteOffset+=o,t.byteLength-=o),e._queueTotalSize-=o,gr(e,o,r),l-=o}return!1===c&&(o(0===e._queueTotalSize),o(r.bytesFilled>0),o(r.bytesFilled<r.elementSize)),c}function gr(e,r,t){o(0===e._pendingPullIntos.length||e._pendingPullIntos[0]===t),Rr(e),t.bytesFilled+=r}function vr(e){o("readable"===e._controlledReadableByteStream._state),0===e._queueTotalSize&&!0===e._closeRequested?Ye(e._controlledReadableByteStream):br(e)}function Rr(e){void 0!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=void 0,e._byobRequest=void 0)}function Pr(e){for(o(!1===e._closeRequested);e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const r=e._pendingPullIntos[0];!0===Sr(e,r)&&(Tr(e),yr(e._controlledReadableByteStream,r))}}function qr(e,r){const t=e._pendingPullIntos[0],n=e._controlledReadableByteStream;if("closed"===n._state){if(0!==r)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");!function(e,r){r.buffer=be(r.buffer),o(0===r.bytesFilled);const t=e._controlledReadableByteStream;if(!0===Ge(t))for(;xe(t)>0;)yr(t,Tr(e))}(e,t)}else o("readable"===n._state),function(e,r,t){if(t.bytesFilled+r>t.byteLength)throw new RangeError("bytesWritten out of range");if(gr(e,r,t),t.bytesFilled<t.elementSize)return;Tr(e);const o=t.bytesFilled%t.elementSize;if(o>0){const r=t.byteOffset+t.bytesFilled,n=t.buffer.slice(r-o,r);wr(e,n,0,n.byteLength)}t.buffer=be(t.buffer),t.bytesFilled-=o,yr(e._controlledReadableByteStream,t),Pr(e)}(e,r,t)}function Tr(e){const r=e._pendingPullIntos.shift();return Rr(e),r}function Cr(e,r){const t=e._controlledReadableByteStream;o("readable"===t._state),hr(e),Pe(e),He(t,r)}function jr(e){const r=e._controlledReadableByteStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function Wr(e,r,t,n,a,i,s){o(void 0===e._readableStreamController),void 0!==s&&(o(!0===Number.isInteger(s)),o(s>0)),r._controlledReadableByteStream=e,r._pullAgain=!1,r._pulling=!1,hr(r),r._queue=r._queueTotalSize=void 0,Pe(r),r._closeRequested=!1,r._started=!1,r._strategyHWM=he(i),r._pullAlgorithm=n,r._cancelAlgorithm=a,r._autoAllocateChunkSize=s,r._pendingPullIntos=[],e._readableStreamController=r;const l=t();Promise.resolve(l).then(()=>{r._started=!0,o(!1===r._pulling),o(!1===r._pullAgain),br(r)},t=>{"readable"===e._state&&Cr(r,t)}).catch(ge)}function Er(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function Ar(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function Or(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}function Br(e,r){o(void 0!==e._closedPromise_resolve),o(void 0!==e._closedPromise_reject),e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function zr(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function Ir(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function kr(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function Fr(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}var Dr=Ie.ReadableStream;const{createDataProperty:Nr}=n;var Lr=class ByteLengthQueuingStrategy{constructor({highWaterMark:e}){Nr(this,"highWaterMark",e)}size(e){return e.byteLength}};const{createDataProperty:Mr}=n;var Vr=class CountQueuingStrategy{constructor({highWaterMark:e}){Mr(this,"highWaterMark",e)}size(){return 1}};const $r=f("streams:transform-stream:verbose"),{InvokeOrNoop:Yr,CreateAlgorithmFromUnderlyingMethod:Hr,PromiseCall:Qr,typeIsObject:xr,ValidateAndNormalizeHighWaterMark:Ur,IsNonNegativeNumber:Gr,MakeSizeAlgorithmFromSizeFunction:Jr}=n,{CreateReadableStream:Kr,ReadableStreamDefaultControllerClose:Xr,ReadableStreamDefaultControllerEnqueue:Zr,ReadableStreamDefaultControllerError:et,ReadableStreamDefaultControllerGetDesiredSize:rt,ReadableStreamDefaultControllerHasBackpressure:tt,ReadableStreamDefaultControllerCanCloseOrEnqueue:ot}=Ie,{CreateWritableStream:nt,WritableStreamDefaultControllerErrorIfNeeded:at}=j;class TransformStream{constructor(e={},r={},t={}){if(void 0!==e.readableType)throw new RangeError("Invalid readable type specified");if(void 0!==e.writableType)throw new RangeError("Invalid writable type specified");const n=r.size,a=Jr(n);let i=r.highWaterMark;void 0===i&&(i=1),i=Ur(i);const s=t.size,l=Jr(s);let c,u=t.highWaterMark;void 0===u&&(u=0),u=Ur(u),it(this,new Promise(e=>{c=e}),i,a,u,l),function(e,r){o(void 0!==r);const t=Object.create(TransformStreamDefaultController.prototype);let n=e=>{try{return ft(t,e),Promise.resolve()}catch(e){return Promise.reject(e)}};const a=r.transform;if(void 0!==a){if("function"!=typeof a)throw new TypeError("transform is not a method");n=(o=>{const n=Qr(a,r,[o,t]);return n.catch(r=>{throw lt(e,r),r})})}const i=Hr(r,"flush",0,[t]);_t(e,t,n,i)}(this,e);const d=Yr(e,"start",[this._transformStreamController]);c(d)}get readable(){if(!1===st(this))throw bt("readable");return this._readable}get writable(){if(!1===st(this))throw bt("writable");return this._writable}}function it(e,r,t,n,a,i){function s(){return r}e._writable=nt(s,function(r){return function(e,r){$r("TransformStreamDefaultSinkWriteAlgorithm()"),o("writable"===e._writable._state);const t=e._transformStreamController;if(!0===e._backpressure){const n=e._backpressureChangePromise;return o(void 0!==n),n.then(()=>{const n=e._writable,a=n._state;if("erroring"===a)throw n._storedError;return o("writable"===a),t._transformAlgorithm(r)})}return t._transformAlgorithm(r)}(e,r)},function(){return function(e){$r("TransformStreamDefaultSinkCloseAlgorithm()");const r=e._readable;return e._transformStreamController._flushAlgorithm().then(()=>{if("errored"===r._state)throw r._storedError;const e=r._readableStreamController;!0===ot(e)&&Xr(e)}).catch(t=>{throw lt(e,t),r._storedError})}(e)},function(){return function(e){const r=new TypeError("Writable side aborted");return lt(e,r),Promise.resolve()}(e)},t,n),e._readable=Kr(s,function(){return function(e){return $r("TransformStreamDefaultSourcePullAlgorithm()"),o(!0===e._backpressure),o(void 0!==e._backpressureChangePromise),ut(e,!1),e._backpressureChangePromise}(e)},function(r){return ct(e,r),Promise.resolve()},a,i),e._backpressure=void 0,e._backpressureChangePromise=void 0,e._backpressureChangePromise_resolve=void 0,ut(e,!0),e._transformStreamController=void 0}function st(e){return!!xr(e)&&!!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")}function lt(e,r){$r("TransformStreamError()"),"readable"===e._readable._state&&et(e._readable._readableStreamController,r),ct(e,r)}function ct(e,r){at(e._writable._writableStreamController,r),!0===e._backpressure&&ut(e,!1)}function ut(e,r){$r(`TransformStreamSetBackpressure() [backpressure = ${r}]`),o(e._backpressure!==r),void 0!==e._backpressureChangePromise&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=new Promise(r=>{e._backpressureChangePromise_resolve=r}),e._backpressure=r}class TransformStreamDefaultController{constructor(){throw new TypeError("TransformStreamDefaultController instances cannot be created directly")}get desiredSize(){if(!1===dt(this))throw mt("desiredSize");const e=this._controlledTransformStream._readable._readableStreamController;return rt(e)}enqueue(e){if(!1===dt(this))throw mt("enqueue");ft(this,e)}error(e){if(!1===dt(this))throw mt("error");!function(e,r){lt(e._controlledTransformStream,r)}(this,e)}terminate(){if(!1===dt(this))throw mt("terminate");!function(e){$r("TransformStreamDefaultControllerTerminate()");const r=e._controlledTransformStream,t=r._readable._readableStreamController;!0===ot(t)&&Xr(t);const o=new TypeError("TransformStream terminated");ct(r,o)}(this)}}function dt(e){return!!xr(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")}function _t(e,r,t,n){o(!0===st(e)),o(void 0===e._transformStreamController),r._controlledTransformStream=e,e._transformStreamController=r,r._transformAlgorithm=t,r._flushAlgorithm=n}function ft(e,r){$r("TransformStreamDefaultControllerEnqueue()");const t=e._controlledTransformStream,n=t._readable._readableStreamController;if(!1===ot(n))throw new TypeError("Readable side is not in a state that permits enqueue");try{Zr(n,r)}catch(e){throw ct(t,e),t._readable._storedError}const a=tt(n);a!==t._backpressure&&(o(!0===a),ut(t,!0))}function mt(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function bt(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}var ht={CreateTransformStream:function(e,r,t,n=1,a=(()=>1),i=0,s=(()=>1)){o(Gr(n)),o(Gr(i));const l=Object.create(TransformStream.prototype);let c;it(l,new Promise(e=>{c=e}),n,a,i,s),_t(l,Object.create(TransformStreamDefaultController.prototype),r,t);const u=e();return c(u),l},TransformStream:TransformStream}.TransformStream;const yt={ReadableStream:Dr,WritableStream:le,ByteLengthQueuingStrategy:Lr,CountQueuingStrategy:Vr,TransformStream:ht};void 0!==c&&Object.assign(c,yt),e.ReadableStream=Dr,e.WritableStream=le,e.ByteLengthQueuingStrategy=Lr,e.CountQueuingStrategy=Vr,e.TransformStream=ht,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=polyfill.wpt.js.map
