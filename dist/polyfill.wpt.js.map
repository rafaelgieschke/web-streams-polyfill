{"version":3,"file":"polyfill.wpt.js","sources":["../src/stub/no-min/better-assert.js","../spec/reference-implementation/lib/helpers.js","../spec/reference-implementation/lib/utils.js","../spec/reference-implementation/lib/queue-with-sizes.js","../src/utils.js","../src/stub/no-min/debug.js","../spec/reference-implementation/lib/writable-stream.js","../spec/reference-implementation/lib/readable-stream.js","../spec/reference-implementation/lib/byte-length-queuing-strategy.js","../spec/reference-implementation/lib/count-queuing-strategy.js","../spec/reference-implementation/lib/transform-stream.js","../src/polyfill.js"],"sourcesContent":["export class AssertionError extends Error {\n}\n\nexport default function assert(test) {\n  if (!test) {\n    throw new AssertionError();\n  }\n}\n","'use strict';\nconst assert = require('better-assert');\n\nconst isFakeDetached = Symbol('is \"detached\" for our purposes');\n\nfunction IsPropertyKey(argument) {\n  return typeof argument === 'string' || typeof argument === 'symbol';\n}\n\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\n\nexports.createDataProperty = (o, p, v) => {\n  assert(exports.typeIsObject(o));\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\n};\n\nexports.createArrayFromList = elements => {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice();\n};\n\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n};\n\nexports.CreateIterResultObject = (value, done) => {\n  assert(typeof done === 'boolean');\n  const obj = {};\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\n  return obj;\n};\n\nexports.IsFiniteNonNegativeNumber = v => {\n  if (exports.IsNonNegativeNumber(v) === false) {\n    return false;\n  }\n\n  if (v === Infinity) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.IsNonNegativeNumber = v => {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (Number.isNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nfunction Call(F, V, args) {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexports.Call = Call;\n\nexports.CreateAlgorithmFromUnderlyingMethod = (underlyingObject, methodName, algoArgCount, extraArgs) => {\n  assert(underlyingObject !== undefined);\n  assert(IsPropertyKey(methodName));\n  assert(algoArgCount === 0 || algoArgCount === 1);\n  assert(Array.isArray(extraArgs));\n  const method = underlyingObject[methodName];\n  if (method !== undefined) {\n    if (typeof method !== 'function') {\n      throw new TypeError(`${method} is not a method`);\n    }\n    switch (algoArgCount) {\n      case 0: {\n        return () => {\n          return PromiseCall(method, underlyingObject, extraArgs);\n        };\n      }\n\n      case 1: {\n        return arg => {\n          const fullArgs = [arg].concat(extraArgs);\n          return PromiseCall(method, underlyingObject, fullArgs);\n        };\n      }\n    }\n  }\n  return () => Promise.resolve();\n};\n\nexports.InvokeOrNoop = (O, P, args) => {\n  assert(O !== undefined);\n  assert(IsPropertyKey(P));\n  assert(Array.isArray(args));\n\n  const method = O[P];\n  if (method === undefined) {\n    return undefined;\n  }\n\n  return Call(method, O, args);\n};\n\nfunction PromiseCall(F, V, args) {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return Promise.resolve(Call(F, V, args));\n  } catch (value) {\n    return Promise.reject(value);\n  }\n}\n\nexports.PromiseCall = PromiseCall;\n\n// Not implemented correctly\nexports.TransferArrayBuffer = O => {\n  assert(!exports.IsDetachedBuffer(O));\n  const transferredIshVersion = O.slice();\n\n  // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\n  // ArrayBuffer and checking if its byteLength starts returning 0.\n  Object.defineProperty(O, 'byteLength', {\n    get() {\n      return 0;\n    }\n  });\n  O[isFakeDetached] = true;\n\n  return transferredIshVersion;\n};\n\n// Not implemented correctly\nexports.IsDetachedBuffer = O => {\n  return isFakeDetached in O;\n};\n\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\n  highWaterMark = Number(highWaterMark);\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n  }\n\n  return highWaterMark;\n};\n\nexports.MakeSizeAlgorithmFromSizeFunction = size => {\n  if (size === undefined) {\n    return () => 1;\n  }\n  if (typeof size !== 'function') {\n    throw new TypeError('size property of a queuing strategy must be a function');\n  }\n  return chunk => size(chunk);\n};\n","'use strict';\nconst assert = require('better-assert');\n\nexports.rethrowAssertionErrorRejection = e => {\n  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n  // expect any errors, but assertion errors are always problematic.\n  if (e && e.constructor === assert.AssertionError) {\n    setTimeout(() => {\n      throw e;\n    }, 0);\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\n\nexports.DequeueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift();\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n};\n\nexports.EnqueueValueWithSize = (container, value, size) => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n};\n\nexports.PeekQueueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue[0];\n  return pair.value;\n};\n\nexports.ResetQueue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = [];\n  container._queueTotalSize = 0;\n};\n","export function noop() {\n  // do nothing\n}\n\nfunction getGlobals() {\n  /* global self, window, global */\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","import { noop } from '../../utils';\n\nfunction createDebugMessage(namespace, message) {\n  return `[${namespace}] ${message}`;\n}\n\nexport default function debug(namespace) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined') {\n    if (typeof console.debug === 'function') {\n      return message => console.debug(createDebugMessage(namespace, message));\n    }\n    if (typeof console.log === 'function') {\n      return message => console.log(createDebugMessage(namespace, message));\n    }\n  }\n  return noop;\n}\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:writable-stream:verbose');\n\nconst { CreateAlgorithmFromUnderlyingMethod, InvokeOrNoop, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, PeekQueueValue, ResetQueue } = require('./queue-with-sizes.js');\n\nconst AbortSteps = Symbol('[[AbortSteps]]');\nconst ErrorSteps = Symbol('[[ErrorSteps]]');\n\nclass WritableStream {\n  constructor(underlyingSink = {}, { size, highWaterMark = 1 } = {}) {\n    InitializeWritableStream(this);\n\n    const type = underlyingSink.type;\n\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  get locked() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  abort(reason) {\n    if (IsWritableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  getWriter() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nmodule.exports = {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream(stream) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = [];\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsWritableStreamLocked(stream) {\n  assert(IsWritableStream(stream) === true);\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream, reason) {\n  const state = stream._state;\n  if (state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n  const error = new TypeError('Requested to abort');\n  if (stream._pendingAbortRequest !== undefined) {\n    return Promise.reject(error);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n\n  if (wasAlreadyErroring === false) {\n    WritableStreamStartErroring(stream, error);\n  }\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream) {\n  assert(IsWritableStreamLocked(stream) === true);\n  assert(stream._state === 'writable');\n\n  const promise = new Promise((resolve, reject) => {\n    const writeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream, error) {\n  verbose('WritableStreamDealWithRejection(stream, %o)', error);\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream, reason) {\n  verbose('WritableStreamStartErroring(stream, %o)', reason);\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream) {\n  verbose('WritableStreamFinishErroring()');\n  assert(stream._state === 'erroring');\n  assert(WritableStreamHasOperationMarkedInFlight(stream) === false);\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  for (const writeRequest of stream._writeRequests) {\n    writeRequest._reject(storedError);\n  }\n  stream._writeRequests = [];\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring === true) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  promise.then(\n      () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      },\n      reason => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    verbose('WritableStreamHasOperationMarkedInFlight() is false');\n    return false;\n  }\n\n  verbose('WritableStreamHasOperationMarkedInFlight() is true');\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  verbose('WritableStreamRejectCloseAndClosedPromiseIfNeeded()');\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n    writer._closedPromise.catch(() => {});\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n  assert(stream._state === 'writable');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure === true) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(backpressure === false);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\nclass WritableStreamDefaultWriter {\n  constructor(stream) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n    }\n    if (IsWritableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n      this._closedPromise.catch(() => {});\n    }\n  }\n\n  get closed() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  get desiredSize() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  get ready() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  abort(reason) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  close() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return Promise.reject(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  releaseLock() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  write(chunk) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.reject(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const promise = new Promise((resolve, reject) => {\n    const closeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  if (stream._backpressure === true && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.resolve();\n  }\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n  writer._closedPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  verbose('WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)', error);\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n  writer._readyPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n}\n\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return Promise.reject(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nclass WritableStreamDefaultController {\n  constructor() {\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n  }\n\n  error(e) {\n    if (IsWritableStreamDefaultController(this) === false) {\n      throw new TypeError(\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  [AbortSteps](reason) {\n    return this._abortAlgorithm(reason);\n  }\n\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                              abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(IsWritableStream(stream) === true);\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = Promise.resolve(startResult);\n  startPromise.then(\n      () => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      },\n      r => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n      }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n  assert(underlyingSink !== undefined);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\n  }\n\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n\nfunction WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize(controller, 'close', 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  const writeRecord = { chunk };\n\n  try {\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  verbose('WritableStreamDefaultControllerAdvanceQueueIfNeeded()');\n  const stream = controller._controlledWritableStream;\n\n  if (controller._started === false) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return;\n  }\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const writeRecord = PeekQueueValue(controller);\n  if (writeRecord === 'close') {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  sinkClosePromise.then(\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  sinkWritePromise.then(\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    reason => {\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller, error) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name) {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = new Promise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  writer._closedPromise = Promise.resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResolve(writer) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer) {\n  verbose('defaultWriterReadyPromiseInitialize()');\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseInitializeAsRejected(writer, %o)', reason);\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  verbose('defaultWriterReadyPromiseInitializeAsResolved()');\n  writer._readyPromise = Promise.resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n  verbose('defaultWriterReadyPromiseReject(writer, %o)', reason);\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer) {\n  verbose('defaultWriterReadyPromiseReset()');\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseResetToRejected(writer, %o)', reason);\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseResolve(writer) {\n  verbose('defaultWriterReadyPromiseResolve()');\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n","'use strict';\nconst assert = require('better-assert');\nconst { ArrayBufferCopy, CreateAlgorithmFromUnderlyingMethod, CreateIterResultObject, IsFiniteNonNegativeNumber,\n        InvokeOrNoop, IsDetachedBuffer, TransferArrayBuffer, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, createArrayFromList, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, ResetQueue } = require('./queue-with-sizes.js');\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight } =\n      require('./writable-stream.js');\n\nconst CancelSteps = Symbol('[[CancelSteps]]');\nconst PullSteps = Symbol('[[PullSteps]]');\n\nclass ReadableStream {\n  constructor(underlyingSource = {}, { size, highWaterMark } = {}) {\n    InitializeReadableStream(this);\n    const type = underlyingSource.type;\n    const typeString = String(type);\n    if (typeString === 'bytes') {\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      if (size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n    } else if (type === undefined) {\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n    } else {\n      throw new RangeError('Invalid type is specified');\n    }\n  }\n\n  get locked() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  getReader({ mode } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    mode = String(mode);\n\n    if (mode === 'byob') {\n      return AcquireReadableStreamBYOBReader(this);\n    }\n\n    throw new RangeError('Invalid mode is specified');\n  }\n\n  pipeThrough({ writable, readable }, options) {\n    if (writable === undefined || readable === undefined) {\n      throw new TypeError('readable and writable arguments must be defined');\n    }\n\n    const promise = this.pipeTo(writable, options);\n\n    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);\n\n    return readable;\n  }\n\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('pipeTo'));\n    }\n    if (IsWritableStream(dest) === false) {\n      return Promise.reject(\n        new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n    }\n    if (IsWritableStreamLocked(dest) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n    }\n\n    const reader = AcquireReadableStreamDefaultReader(this);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n\n    let shuttingDown = false;\n\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      // Using reader and writer, read all chunks from this and write them to dest\n      // - Backpressure must be enforced\n      // - Shutdown must stop all activity\n      function pipeLoop() {\n        if (shuttingDown === true) {\n          return Promise.resolve();\n        }\n\n        return writer._readyPromise.then(() => {\n          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\n            if (done === true) {\n              return;\n            }\n\n            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(() => {});\n          });\n        })\n        .then(pipeLoop);\n      }\n\n      // Errors must be propagated forward\n      isOrBecomesErrored(this, reader._closedPromise, storedError => {\n        if (preventAbort === false) {\n          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Errors must be propagated backward\n      isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Closing must be propagated forward\n      isOrBecomesClosed(this, reader._closedPromise, () => {\n        if (preventClose === false) {\n          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n        } else {\n          shutdown();\n        }\n      });\n\n      // Closing must be propagated backward\n      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\n        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);\n        } else {\n          shutdown(true, destClosed);\n        }\n      }\n\n      pipeLoop().catch(err => {\n        currentWrite = Promise.resolve();\n        rethrowAssertionErrorRejection(err);\n      });\n\n      function waitForWritesToFinish() {\n        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n        // for that too.\n        const oldCurrentWrite = currentWrite;\n        return currentWrite.then(() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n      }\n\n      function isOrBecomesErrored(stream, promise, action) {\n        if (stream._state === 'errored') {\n          action(stream._storedError);\n        } else {\n          promise.catch(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function isOrBecomesClosed(stream, promise, action) {\n        if (stream._state === 'closed') {\n          action();\n        } else {\n          promise.then(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdownWithAction(action, originalIsError, originalError) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(doTheRest);\n        } else {\n          doTheRest();\n        }\n\n        function doTheRest() {\n          action().then(\n            () => finalize(originalIsError, originalError),\n            newError => finalize(true, newError)\n          )\n          .catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdown(isError, error) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(() => finalize(isError, error)).catch(rethrowAssertionErrorRejection);\n        } else {\n          finalize(isError, error);\n        }\n      }\n\n      function finalize(isError, error) {\n        WritableStreamDefaultWriterRelease(writer);\n        ReadableStreamReaderGenericRelease(reader);\n\n        if (isError) {\n          reject(error);\n        } else {\n          resolve(undefined);\n        }\n      }\n    });\n  }\n\n  tee() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return createArrayFromList(branches);\n  }\n}\n\nmodule.exports = {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  ReadableStream,\n  IsReadableStreamDisturbed,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure,\n  ReadableStreamDefaultControllerCanCloseOrEnqueue\n};\n\n// Abstract operations for the ReadableStream.\n\nfunction AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n}\n\nfunction AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  SetUpReadableStreamDefaultController(\n      stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 0,\n                                  autoAllocateChunkSize = undefined) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nfunction IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDisturbed(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  return stream._disturbed;\n}\n\nfunction IsReadableStreamLocked(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n  assert(IsReadableStream(stream) === true);\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader(stream);\n\n  let closedOrErrored = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n\n  let resolveCancelPromise;\n  const cancelPromise = new Promise(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm() {\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\n      assert(typeIsObject(result));\n      const value = result.value;\n      const done = result.done;\n      assert(typeof done === 'boolean');\n\n      if (done === true && closedOrErrored === false) {\n        if (canceled1 === false) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n        if (canceled2 === false) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n        closedOrErrored = true;\n      }\n\n      if (closedOrErrored === true) {\n        return;\n      }\n\n      const value1 = value;\n      const value2 = value;\n\n      // There is no way to access the cloning code right now in the reference implementation.\n      // If we add one then we'll need an implementation for serializable objects.\n      // if (canceled2 === false && cloneForBranch2 === true) {\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n      // }\n\n      if (canceled1 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n      }\n\n      if (canceled2 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n      }\n    });\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {}\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  reader._closedPromise.catch(r => {\n    if (closedOrErrored === true) {\n      return;\n    }\n\n    ReadableStreamDefaultControllerErrorIfNeeded(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerErrorIfNeeded(branch2._readableStreamController, r);\n    closedOrErrored = true;\n  });\n\n  return [branch1, branch2];\n}\n\n// ReadableStream API exposed for controllers.\n\nfunction ReadableStreamAddReadIntoRequest(stream) {\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  const promise = new Promise((resolve, reject) => {\n    const readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamAddReadRequest(stream) {\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\n  assert(stream._state === 'readable');\n\n  const promise = new Promise((resolve, reject) => {\n    const readRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._reader._readRequests.push(readRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return sourceCancelPromise.then(() => undefined);\n}\n\nfunction ReadableStreamClose(stream) {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const { _resolve } of reader._readRequests) {\n      _resolve(CreateIterResultObject(undefined, true));\n    }\n    reader._readRequests = [];\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  return undefined;\n}\n\nfunction ReadableStreamError(stream, e) {\n  assert(IsReadableStream(stream) === true);\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const readRequest of reader._readRequests) {\n      readRequest._reject(e);\n    }\n\n    reader._readRequests = [];\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n\n    for (const readIntoRequest of reader._readIntoRequests) {\n      readIntoRequest._reject(e);\n    }\n\n    reader._readIntoRequests = [];\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n  reader._closedPromise.catch(() => {});\n}\n\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift();\n  readIntoRequest._resolve(CreateIterResultObject(chunk, done));\n}\n\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift();\n  readRequest._resolve(CreateIterResultObject(chunk, done));\n}\n\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\n\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\n\nfunction ReadableStreamHasBYOBReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamBYOBReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamHasDefaultReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nclass ReadableStreamDefaultReader {\n  constructor(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n    }\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = [];\n  }\n\n  get closed() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    return ReadableStreamDefaultReaderRead(this);\n  }\n\n  releaseLock() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nclass ReadableStreamBYOBReader {\n  constructor(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\n          'byte source');\n    }\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n          'source');\n    }\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = [];\n  }\n\n  get closed() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return Promise.reject(new TypeError('view must be an array buffer view'));\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\n    }\n\n    if (view.byteLength === 0) {\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\n    }\n\n    return ReadableStreamBYOBReaderRead(this, view);\n  }\n\n  releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\n// Abstract operations for the readers.\n\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    reader._closedPromise.catch(() => {});\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nfunction ReadableStreamReaderGenericRelease(reader) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n  reader._closedPromise.catch(() => {});\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n\nfunction ReadableStreamBYOBReaderRead(reader, view) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  // Controllers must implement this.\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\n}\n\nfunction ReadableStreamDefaultReaderRead(reader) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(CreateIterResultObject(undefined, true));\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(stream._state === 'readable');\n\n  return stream._readableStreamController[PullSteps]();\n}\n\n// Controllers\n\nclass ReadableStreamDefaultController {\n  constructor() {\n    throw new TypeError();\n  }\n\n  get desiredSize() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    const stream = this._controlledReadableStream;\n    if (stream._state !== 'readable') {\n      throw new TypeError(`The stream is ${stream._state} and so cannot be errored`);\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    ResetQueue(this);\n    return this._cancelAlgorithm(reason);\n  }\n\n  [PullSteps]() {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      return Promise.resolve(CreateIterResultObject(chunk, false));\n    }\n\n    const pendingPromise = ReadableStreamAddReadRequest(stream);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  }\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n      return undefined;\n    },\n    e => {\n      ReadableStreamDefaultControllerErrorIfNeeded(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction ReadableStreamDefaultControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamClose(stream);\n  }\n}\n\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n\n  assert(stream._state === 'readable');\n\n  ResetQueue(controller);\n\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableStreamDefaultControllerErrorIfNeeded(controller, e) {\n  if (controller._controlledReadableStream._state === 'readable') {\n    ReadableStreamDefaultControllerError(controller, e);\n  }\n}\n\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const state = controller._controlledReadableStream._state;\n\n  if (controller._closeRequested === false && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction SetUpReadableStreamDefaultController(\n  stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n    () => {\n      controller._started = true;\n\n      assert(controller._pulling === false);\n      assert(controller._pullAgain === false);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableStreamDefaultControllerErrorIfNeeded(controller, r);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark,\n                                                                  sizeAlgorithm) {\n  assert(underlyingSource !== undefined);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\n\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                       highWaterMark, sizeAlgorithm);\n}\n\nclass ReadableStreamBYOBRequest {\n  constructor() {\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n  }\n\n  get view() {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view.buffer) === true) {\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nclass ReadableByteStreamController {\n  constructor() {\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n  }\n\n  get byobRequest() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      const view = new Uint8Array(firstDescriptor.buffer,\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n      this._byobRequest = byobRequest;\n    }\n\n    return this._byobRequest;\n  }\n\n  get desiredSize() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n    }\n\n    if (IsDetachedBuffer(chunk.buffer) === true) {\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    const stream = this._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n      throw new TypeError(`The stream is ${stream._state} and so cannot be errored`);\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    if (this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      firstDescriptor.bytesFilled = 0;\n    }\n\n    ResetQueue(this);\n\n    return this._cancelAlgorithm(reason);\n  }\n\n  [PullSteps]() {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream) === true);\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      const entry = this._queue.shift();\n      this._queueTotalSize -= entry.byteLength;\n\n      ReadableByteStreamControllerHandleQueueDrain(this);\n\n      let view;\n      try {\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n      } catch (viewE) {\n        return Promise.reject(viewE);\n      }\n\n      return Promise.resolve(CreateIterResultObject(view, false));\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        return Promise.reject(bufferE);\n      }\n\n      const pullIntoDescriptor = {\n        buffer,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        ctor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    const promise = ReadableStreamAddReadRequest(stream);\n\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n\n    return promise;\n  }\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      if (controller._controlledReadableByteStream._state === 'readable') {\n        ReadableByteStreamControllerError(controller, e);\n      }\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = [];\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  assert(stream._state !== 'errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.ctor(\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue[0];\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (ready === false) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  assert(controller._closeRequested === false);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerPullInto(controller, view) {\n  const stream = controller._controlledReadableByteStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor;\n\n  const buffer = TransferArrayBuffer(view.buffer);\n  const pullIntoDescriptor = {\n    buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    return ReadableStreamAddReadIntoRequest(stream);\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    return Promise.resolve(CreateIterResultObject(emptyView, true));\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      return Promise.resolve(CreateIterResultObject(filledView, false));\n    }\n\n    if (controller._closeRequested === true) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      return Promise.reject(e);\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  const promise = ReadableStreamAddReadIntoRequest(stream);\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n\n  return promise;\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  assert(firstDescriptor.bytesFilled === 0);\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream) === true) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n    throw new RangeError('bytesWritten out of range');\n  }\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(stream._state === 'readable');\n\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  const descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nfunction ReadableByteStreamControllerClose(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableStreamClose(stream);\n}\n\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(IsReadableStreamLocked(stream) === false);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n}\n\nfunction ReadableByteStreamControllerError(controller, e) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(stream._state === 'readable');\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableByteStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n    throw new RangeError('bytesWritten must be a finite');\n  }\n\n  assert(controller._pendingPullIntos.length > 0);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n\n  firstDescriptor.buffer = view.buffer;\n\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                           highWaterMark, autoAllocateChunkSize) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = [];\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n\n        assert(controller._pulling === false);\n        assert(controller._pullAgain === false);\n\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      },\n      r => {\n        if (stream._state === 'readable') {\n          ReadableByteStreamControllerError(controller, r);\n        }\n      }\n  )\n      .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n  assert(underlyingByteSource !== undefined);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\n\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize !== undefined) {\n    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\n    }\n  }\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n}\n\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n  assert(IsReadableByteStreamController(controller) === true);\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view) === true);\n  assert(IsDetachedBuffer(view.buffer) === false);\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\n// Helper functions for the readers.\n\nfunction readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\nfunction defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = new Promise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  reader._closedPromise = Promise.resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  reader._closedPromise = Promise.reject(reason);\n}\n\nfunction defaultReaderClosedPromiseResolve(reader) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction byobReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Helper function for ReadableStream pipeThrough\n\nfunction ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {\n  try {\n    // This relies on the brand-check that is enforced by Promise.prototype.then(). As with the rest of the reference\n    // implementation, it doesn't attempt to do the right thing if someone has modified the global environment.\n    Promise.prototype.then.call(promise, undefined, () => {});\n  } catch (e) {\n    // The brand check failed, therefore the internal slot is not present and there's nothing further to do.\n  }\n}\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class ByteLengthQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size(chunk) {\n    return chunk.byteLength;\n  }\n};\n","'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class CountQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size() {\n    return 1;\n  }\n};\n","'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:transform-stream:verbose');\nconst { InvokeOrNoop, CreateAlgorithmFromUnderlyingMethod, PromiseCall, typeIsObject,\n        ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction } = require('./helpers.js');\nconst { CreateReadableStream, ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue,\n        ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize,\n        ReadableStreamDefaultControllerHasBackpressure,\n        ReadableStreamDefaultControllerCanCloseOrEnqueue } = require('./readable-stream.js');\nconst { CreateWritableStream, WritableStreamDefaultControllerErrorIfNeeded } = require('./writable-stream.js');\n\n// Class TransformStream\n\nclass TransformStream {\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\n    const readableType = transformer.readableType;\n\n    if (readableType !== undefined) {\n      throw new RangeError('Invalid readable type specified');\n    }\n\n    const writableType = transformer.writableType;\n\n    if (writableType !== undefined) {\n      throw new RangeError('Invalid writable type specified');\n    }\n\n    const writableSizeFunction = writableStrategy.size;\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\n    let writableHighWaterMark = writableStrategy.highWaterMark;\n    if (writableHighWaterMark === undefined) {\n      writableHighWaterMark = 1;\n    }\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\n\n    const readableSizeFunction = readableStrategy.size;\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\n    let readableHighWaterMark = readableStrategy.highWaterMark;\n    if (readableHighWaterMark === undefined) {\n      readableHighWaterMark = 0;\n    }\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\n\n    let startPromise_resolve;\n    const startPromise = new Promise(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                              readableSizeAlgorithm);\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\n    startPromise_resolve(startResult);\n  }\n\n  get readable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  get writable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\n// Transform Stream Abstract Operations\n\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark = 1,\n                               writableSizeAlgorithm = () => 1, readableHighWaterMark = 0,\n                               readableSizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve;\n  const startPromise = new Promise(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm,\n                                   readableHighWaterMark, readableSizeAlgorithm) {\n  function startAlgorithm() {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk) {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm() {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream);\n  }\n\n  function closeAlgorithm() {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm() {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason) {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return Promise.resolve();\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true);\n\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n  stream._transformStreamController = undefined;\n}\n\nfunction IsTransformStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n  verbose('TransformStreamError()');\n\n  if (stream._readable._state === 'readable') {\n    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  }\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure === true) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n  verbose(`TransformStreamSetBackpressure() [backpressure = ${backpressure}]`);\n\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = new Promise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\nclass TransformStreamDefaultController {\n  constructor() {\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n  }\n\n  get desiredSize() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  enqueue(chunk) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(reason) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  terminate() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  assert(IsTransformStream(stream) === true);\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  assert(transformer !== undefined);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm = chunk => {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\n      return Promise.resolve();\n    } catch (transformResultE) {\n      return Promise.reject(transformResultE);\n    }\n  };\n  const transformMethod = transformer.transform;\n  if (transformMethod !== undefined) {\n    if (typeof transformMethod !== 'function') {\n      throw new TypeError('transform is not a method');\n    }\n    transformAlgorithm = chunk => {\n      const transformPromise = PromiseCall(transformMethod, transformer, [chunk, controller]);\n      return transformPromise.catch(e => {\n        TransformStreamError(stream, e);\n        throw e;\n      });\n    };\n  }\n\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  verbose('TransformStreamDefaultControllerEnqueue()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure === true);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerTerminate(controller) {\n  verbose('TransformStreamDefaultControllerTerminate()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n    ReadableStreamDefaultControllerClose(readableController);\n  }\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  verbose('TransformStreamDefaultSinkWriteAlgorithm()');\n\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure === true) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return backpressureChangePromise\n        .then(() => {\n          const writable = stream._writable;\n          const state = writable._state;\n          if (state === 'erroring') {\n            throw writable._storedError;\n          }\n          assert(state === 'writable');\n          return controller._transformAlgorithm(chunk);\n        });\n  }\n\n  return controller._transformAlgorithm(chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream) {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  const e = new TypeError('Writable side aborted');\n  TransformStreamError(stream, e);\n  return Promise.resolve();\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  verbose('TransformStreamDefaultSinkCloseAlgorithm()');\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  const flushPromise = stream._transformStreamController._flushAlgorithm();\n  // Return a promise that is fulfilled with undefined on success.\n  return flushPromise.then(() => {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n    const readableController = readable._readableStreamController;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n      ReadableStreamDefaultControllerClose(readableController);\n    }\n  }).catch(r => {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n  verbose('TransformStreamDefaultSourcePullAlgorithm()');\n\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure === true);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\nmodule.exports = { CreateTransformStream, TransformStream };\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n","import {\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  ReadableStream,\n  TransformStream,\n  WritableStream\n} from './ponyfill';\nimport { globals } from './utils';\n\n// Export\nexport * from './ponyfill';\n\nconst exports = {\n  ReadableStream,\n  WritableStream,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  TransformStream\n};\n\n// Add classes to global scope\nif (typeof globals !== 'undefined') {\n  Object.assign(globals, exports);\n}\n"],"names":["AssertionError","Error","assert","test","isFakeDetached","Symbol","IsPropertyKey","argument","Call","F","V","args","TypeError","Function","prototype","apply","call","PromiseCall","undefined","Array","isArray","Promise","resolve","value","reject","exports","x","o","p","v","typeIsObject","Object","defineProperty","writable","enumerable","configurable","elements","slice","dest","destOffset","src","srcOffset","n","Uint8Array","set","done","obj","IsNonNegativeNumber","Infinity","Number","isNaN","underlyingObject","methodName","algoArgCount","extraArgs","method","arg","fullArgs","concat","O","P","IsDetachedBuffer","transferredIshVersion","get","highWaterMark","RangeError","size","chunk","e","constructor","setTimeout","IsFiniteNonNegativeNumber","require$$0","container","_queue","length","pair","shift","_queueTotalSize","push","noop","globals","self","window","global","createDebugMessage","namespace","message","debug","console","log","verbose","CreateAlgorithmFromUnderlyingMethod","InvokeOrNoop","ValidateAndNormalizeHighWaterMark","MakeSizeAlgorithmFromSizeFunction","require$$1","rethrowAssertionErrorRejection","require$$2","DequeueValue","EnqueueValueWithSize","PeekQueueValue","ResetQueue","require$$3","AbortSteps","ErrorSteps","WritableStream","[object Object]","underlyingSink","InitializeWritableStream","this","type","sizeAlgorithm","stream","controller","create","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","SetUpWritableStreamDefaultControllerFromUnderlyingSink","locked","IsWritableStream","streamBrandCheckException","IsWritableStreamLocked","reason","WritableStreamAbort","AcquireWritableStreamDefaultWriter","CreateWritableStream","startAlgorithm","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultWriterCloseWithErrorPropagation","writer","_ownerWritableStream","state","_state","WritableStreamCloseQueuedOrInFlight","_storedError","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriter","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","hasOwnProperty","error","wasAlreadyErroring","promise","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","WritableStreamDealWithRejection","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","_started","storedError","writeRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","then","WritableStreamFinishInFlightClose","_closedPromise_resolve","_closedPromise_reject","_closedPromiseState","defaultWriterClosedPromiseResolve","defaultWriterClosedPromiseReject","_closedPromise","catch","WritableStreamUpdateBackpressure","backpressure","_readyPromise_resolve","_readyPromise_reject","_readyPromise","_readyPromiseState","defaultWriterReadyPromiseReset","defaultWriterReadyPromiseResolve","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseInitializeAsRejected","closed","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","desiredSize","defaultWriterLockException","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","ready","WritableStreamDefaultWriterAbort","closeRequest","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDefaultControllerClose","WritableStreamDefaultWriterEnsureClosedPromiseRejected","defaultWriterClosedPromiseResetToRejected","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","releasedError","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerGetChunkSize","WritableStreamAddWriteRequest","writeRecord","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","WritableStreamDefaultControllerWrite","IsWritableStreamDefaultController","WritableStreamDefaultControllerError","_abortAlgorithm","_strategyHWM","_writeAlgorithm","_closeAlgorithm","startResult","r","WritableStreamMarkCloseRequestInFlight","WritableStreamFinishInFlightCloseWithError","WritableStreamDefaultControllerProcessClose","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamDefaultControllerProcessWrite","name","ArrayBufferCopy","CreateIterResultObject","TransferArrayBuffer","createArrayFromList","CancelSteps","PullSteps","ReadableStream","underlyingSource","InitializeReadableStream","String","underlyingByteSource","ReadableByteStreamController","pullAlgorithm","cancelAlgorithm","autoAllocateChunkSize","isInteger","SetUpReadableByteStreamController","SetUpReadableByteStreamControllerFromUnderlyingSource","ReadableStreamDefaultController","SetUpReadableStreamDefaultController","SetUpReadableStreamDefaultControllerFromUnderlyingSource","IsReadableStream","IsReadableStreamLocked","ReadableStreamCancel","mode","AcquireReadableStreamDefaultReader","ReadableStreamBYOBReader","AcquireReadableStreamBYOBReader","readable","options","ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue","pipeTo","preventClose","preventAbort","preventCancel","Boolean","reader","shuttingDown","currentWrite","isOrBecomesErrored","shutdownWithAction","shutdown","action","isOrBecomesClosed","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","ReadableStreamReaderGenericRelease","pipeLoop","ReadableStreamDefaultReaderRead","err","branches","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","closedOrErrored","canceled1","canceled2","cancelPromise","result","ReadableStreamDefaultControllerClose","_readableStreamController","value1","value2","ReadableStreamDefaultControllerEnqueue","CreateReadableStream","compositeReason","cancelResult","ReadableStreamDefaultControllerErrorIfNeeded","ReadableStreamTee","CreateReadableByteStream","IsReadableStreamDisturbed","_disturbed","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerHasBackpressure","ReadableStreamDefaultControllerShouldCallPull","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultReader","_reader","ReadableStreamAddReadIntoRequest","IsReadableStreamBYOBReader","readIntoRequest","_readIntoRequests","ReadableStreamAddReadRequest","IsReadableStreamDefaultReader","readRequest","_readRequests","ReadableStreamClose","defaultReaderClosedPromiseResolve","ReadableStreamError","defaultReaderClosedPromiseReject","ReadableStreamFulfillReadRequest","ReadableStreamGetNumReadIntoRequests","ReadableStreamGetNumReadRequests","ReadableStreamHasBYOBReader","ReadableStreamHasDefaultReader","ReadableStreamReaderGenericInitialize","defaultReaderBrandCheckException","_ownerReadableStream","readerLockException","ReadableStreamReaderGenericCancel","IsReadableByteStreamController","byobReaderBrandCheckException","view","ArrayBuffer","isView","buffer","byteLength","_controlledReadableByteStream","elementSize","DataView","BYTES_PER_ELEMENT","ctor","pullIntoDescriptor","byteOffset","bytesFilled","readerType","_pendingPullIntos","emptyView","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","ReadableByteStreamControllerHandleQueueDrain","_closeRequested","ReadableByteStreamControllerError","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerPullInto","ReadableStreamBYOBReaderRead","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","defaultReaderClosedPromiseResetToRejected","IsReadableStreamDefaultController","defaultControllerBrandCheckException","_controlledReadableStream","_cancelAlgorithm","ReadableStreamDefaultControllerCallPullIfNeeded","pendingPromise","_pulling","_pullAgain","_pullAlgorithm","ReadableStreamBYOBRequest","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_view","bytesWritten","_associatedReadableByteStreamController","ReadableByteStreamControllerRespondInternal","ReadableByteStreamControllerRespond","firstDescriptor","ReadableByteStreamControllerRespondWithNewView","byobRequest","byteStreamControllerBrandCheckException","_byobRequest","request","SetUpReadableStreamBYOBRequest","ReadableByteStreamControllerGetDesiredSize","firstPendingPullInto","ReadableByteStreamControllerClose","transferredBuffer","ReadableByteStreamControllerEnqueueChunkToQueue","transferredView","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerEnqueue","entry","viewE","_autoAllocateChunkSize","bufferE","ReadableByteStreamControllerShouldCallPull","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerCommitPullIntoDescriptor","ReadableStreamFulfillReadIntoRequest","currentAlignedBytes","maxBytesToCopy","Math","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInClosedState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInReadableState","descriptor","createDataProperty","ByteLengthQueuingStrategy","CountQueuingStrategy","TransformStream","transformer","writableStrategy","readableStrategy","readableType","writableType","writableSizeFunction","writableSizeAlgorithm","writableHighWaterMark","readableSizeFunction","readableSizeAlgorithm","startPromise_resolve","readableHighWaterMark","InitializeTransformStream","TransformStreamDefaultController","transformAlgorithm","TransformStreamDefaultControllerEnqueue","transformResultE","transformMethod","transform","transformPromise","TransformStreamError","flushAlgorithm","SetUpTransformStreamDefaultController","SetUpTransformStreamDefaultControllerFromTransformer","_transformStreamController","IsTransformStream","_readable","_writable","startPromise","backpressureChangePromise","_backpressureChangePromise","_transformAlgorithm","TransformStreamDefaultSinkWriteAlgorithm","_flushAlgorithm","readableController","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamSetBackpressure","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","_backpressureChangePromise_resolve","IsTransformStreamDefaultController","_controlledTransformStream","TransformStreamDefaultControllerError","TransformStreamDefaultControllerTerminate","CreateTransformStream","assign"],"mappings":"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"}